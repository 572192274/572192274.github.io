<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GoBase</title>
      <link href="/2024/04/20/Go/GoBase/"/>
      <url>/2024/04/20/Go/GoBase/</url>
      
        <content type="html"><![CDATA[<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h1 id="Go基础"><a href="#Go基础" class="headerlink" title="Go基础"></a>Go基础</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是数据地址的名字，变量可以在程序中修改其值。用于数据变化</p><p>变量名不能包含空格，不能使用关键字（如if），</p><p>分为全局变量和局部变量</p><p>默认值：</p><ul><li>整型：0</li><li>浮点型：0.0</li><li>布尔：false</li><li>字符串：空字符串</li><li>指针型：nil</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>变量有其生效的区域，这个区域，我们称之为<code>作用域</code>。</p><ul><li>函数内部声明的变量，为<code>局部变量</code>，作用域仅限于函数内部</li><li>函数外部声明的变量，为<code>全局变量</code>，作用域在当前包有效，如果首字母大写，在所有包有效</li><li><code>&#123;&#125;</code>包括的区域，称之为代码块，如果变量定义在<code>&#123;&#125;</code>内部，只在代码块内有效</li></ul><h3 id="声明定义变量"><a href="#声明定义变量" class="headerlink" title="声明定义变量"></a>声明定义变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一种：指定变量类型，声明后若不赋值，使用默认值</span></span><br><span class="line">    <span class="comment">//int 的默认值是0</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a=&quot;</span>, a)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二种：根据值自行判定变量类型(类型推导)</span></span><br><span class="line">    <span class="keyword">var</span> b= <span class="number">10.11</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b=&quot;</span>, b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三种：省略var，注意:=左侧的变量不应该是已经声明过的，否则会导致编译错误</span></span><br><span class="line">    <span class="comment">//下面的方式等价var num string name = &quot;tom&quot;</span></span><br><span class="line">    <span class="comment">//:=的:不能省略，否则错误</span></span><br><span class="line">    c := <span class="string">&quot;tom&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;c=&quot;</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量定义变量"><a href="#批量定义变量" class="headerlink" title="批量定义变量"></a>批量定义变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//一次性声明多个变量</span></span><br><span class="line">    <span class="keyword">var</span> n1, n2, n3 <span class="type">int</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;n1=&quot;</span>, n1, <span class="string">&quot;n2=&quot;</span>, n2, <span class="string">&quot;n3=&quot;</span>, n3)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一次性声明多个变量的方式2</span></span><br><span class="line">    <span class="keyword">var</span> t1, t2, t3 = <span class="number">100</span>, <span class="string">&quot;tom&quot;</span>, <span class="number">888</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;t1=&quot;</span>, t1, <span class="string">&quot;t2=&quot;</span>, t2, <span class="string">&quot;t3=&quot;</span>, t3)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一次性声明多个变量的方式3，同样可以使用类型推导</span></span><br><span class="line">    f1, f2, f3 := <span class="number">100</span>, <span class="string">&quot;tom&quot;</span>, <span class="number">888</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;f1=&quot;</span>, f1, <span class="string">&quot;f2=&quot;</span>, f2, <span class="string">&quot;f3=&quot;</span>, f3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>定义成大写，可被其他文件调用。</p><p>全局变量的生命周期跟随程序的生命周期</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//定义全局变量</span></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> h2 = <span class="number">200</span></span><br><span class="line"><span class="keyword">var</span> h3 = <span class="string">&quot;jack&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的声明方式，也可以改成一次性声明</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">        n3 = <span class="number">300</span></span><br><span class="line">        n4 = <span class="number">900</span></span><br><span class="line">        n5 = <span class="string">&quot;mary&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;h1=&quot;</span>, h1, <span class="string">&quot;h2=&quot;</span>, h2, <span class="string">&quot;h3=&quot;</span>, h3)</span><br><span class="line">    fmt.Println(<span class="string">&quot;n3=&quot;</span>, n3, <span class="string">&quot;n4=&quot;</span>, n4, <span class="string">&quot;n5=&quot;</span>, n5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量不能在整个程序生命周期内不能被修改</p><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><p>(1)常量使用const关键字</p><p>(2)常量在定义的时候，必须初始化</p><p>(3)常量不能修改</p><p>(4)常量只能修饰bool、数值类型(int、float系列)、string类型</p><p>(5)语法：const identifier [type] &#x3D;value</p><h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><p>在golang中并没有枚举这种类型，但在go中有类似的方式，就是使用<code>iota</code>常量生成器。从定义开始，iota值从0加1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iota从定义开始，每行开始自增1</span></span><br><span class="line"><span class="comment">// 当遇到新的赋值后，例如d和f，后续没有重新赋值iota，那么后续常量还是之前的赋值，如e和g</span></span><br><span class="line"><span class="comment">// 又赋值为iota后，看自增到多少，如h和i</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   a = <span class="literal">iota</span></span><br><span class="line">   b        </span><br><span class="line">   c = <span class="literal">iota</span>+<span class="number">2</span>     </span><br><span class="line">   d = <span class="string">&quot;hi&quot;</span> </span><br><span class="line">   e      </span><br><span class="line">   f = <span class="number">100</span>  </span><br><span class="line">   g        </span><br><span class="line">   h, i = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(a, b, c, d, e, f, g, h, i)</span><br><span class="line">   <span class="comment">// 输出: 0 1 4 hi hi 100 100 8 7</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">const</span> name=<span class="string">&quot;tom&quot;</span> <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">const</span> tax <span class="type">float64</span>=<span class="number">0.8</span> <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">const</span> a <span class="type">int</span> <span class="comment">//error,没有初始化值</span></span><br><span class="line">    <span class="keyword">const</span> b=<span class="number">9</span>/<span class="number">3</span> <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">const</span> c = getVal() <span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Golang 更明确的数字类型命名，支持 Unicode，支持常用数据结构。</p><table><thead><tr><th>类型</th><th>长度(字节)</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>FALSE</td><td></td></tr><tr><td>byte</td><td>1</td><td>0</td><td>uint8</td></tr><tr><td>rune</td><td>4</td><td>0</td><td>Unicode Code Point, int32</td></tr><tr><td>int, uint</td><td>4或8</td><td>0</td><td>32 或 64 位</td></tr><tr><td>int8, uint8</td><td>1</td><td>0</td><td>-128 ~ 127, 0 ~ 255，byte是uint8 的别名</td></tr><tr><td>int16, uint16</td><td>2</td><td>0</td><td>-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td>int32, uint32</td><td>4</td><td>0</td><td>-21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名</td></tr><tr><td>int64, uint64</td><td>8</td><td>0</td><td></td></tr><tr><td>float32</td><td>4</td><td>0</td><td></td></tr><tr><td>float64</td><td>8</td><td>0</td><td></td></tr><tr><td>complex64</td><td>8</td><td></td><td></td></tr><tr><td>complex128</td><td>16</td><td></td><td></td></tr><tr><td>uintptr</td><td>4或8</td><td></td><td>以存储指针的 uint32 或 uint64 整数</td></tr><tr><td>array</td><td></td><td></td><td>值类型</td></tr><tr><td>struct</td><td></td><td></td><td>值类型</td></tr><tr><td>string</td><td></td><td>“”</td><td>UTF-8 字符串</td></tr><tr><td>slice</td><td></td><td>nil</td><td>引用类型</td></tr><tr><td>map</td><td></td><td>nil</td><td>引用类型</td></tr><tr><td>channel</td><td></td><td>nil</td><td>引用类型</td></tr><tr><td>interface</td><td></td><td>nil</td><td>接口</td></tr><tr><td>function</td><td></td><td>nil</td><td>函数</td></tr></tbody></table><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ul><li>有符号整型</li></ul><p>分类：int、int8、int16、int32、int64</p><p>数据范围：<code>-2^(n-1) 到 2^(n-1)-1</code></p><p>正数使用原码表示，最高位为0，故int8的正数取值范围为0到2^(7)-1（0000 0000 ~ 0111 1111）</p><p>负数使用补码表示，最高位为1，故int8的负数取值范围为-2^(7)到-1（1000 0000 ~ 1111 1111）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span>=<span class="number">1</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int8</span>=<span class="number">2</span></span><br><span class="line">   <span class="comment">// 其他int16,int32，int64类推</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>,a)</span><br><span class="line">   fmt.Println(<span class="string">&quot;b=&quot;</span>,b)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//查看某个变量的数据类型</span></span><br><span class="line">   <span class="comment">//查看某个变量的占用字节大小</span></span><br><span class="line">   <span class="comment">// 输出：b的类型int8 b占用的字节数是1</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;b的类型%T b占用的字节数是%d\n&quot;</span>, b, unsafe.Sizeof(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无符号整型</li></ul><p>uint、uint8、uint16、uint32、uint64、uintptr</p><p>无符号整型范围: <code> 0 到 2^n-1</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">uint</span>=<span class="number">1</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">uint8</span>=<span class="number">2</span></span><br><span class="line">   <span class="comment">// 其他uint16,uint32，uint64类推</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>,a)</span><br><span class="line">   fmt.Println(<span class="string">&quot;b=&quot;</span>,b)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//查看某个变量的数据类型</span></span><br><span class="line">   <span class="comment">//查看某个变量的占用字节大小</span></span><br><span class="line">   <span class="comment">// 输出：b的类型uint8 b占用的字节数是1</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;b的类型%T b占用的字节数是%d\n&quot;</span>, b, unsafe.Sizeof(b))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// uintptr用法</span></span><br><span class="line">   <span class="comment">// 无符号的整型 uintptr，是用于存放指针的，它没有指定具体的 bit 大小但是足以容纳指针</span></span><br><span class="line">   <span class="comment">// uintptr的值表示了内存中的一个地址位置，它是一个整数，用于存储和计算指针的数值，但并不直接引用任何对象</span></span><br><span class="line">   <span class="comment">// 定义一个 int 变量</span></span><br><span class="line">   x := <span class="number">42</span></span><br><span class="line">   <span class="comment">// 获取 x 的地址，并转换为 uintptr</span></span><br><span class="line">   ptrUint := <span class="type">uintptr</span>(unsafe.Pointer(&amp;x))</span><br><span class="line">   <span class="comment">// 将 uintptr 转换回 *int 指针</span></span><br><span class="line">   ptrInt := (*<span class="type">int</span>)(unsafe.Pointer(ptrUint))</span><br><span class="line">   <span class="comment">// 通过转换后的指针修改 x 的值</span></span><br><span class="line">   *ptrInt = <span class="number">1337</span></span><br><span class="line">   <span class="comment">// 输出修改后的 x 值</span></span><br><span class="line">   fmt.Println(x) <span class="comment">// 输出: 1337</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。</p><p>这两种浮点型数据格式遵循<code>IEEE 754</code>标准</p><p><code>float32</code> 的浮点数的最大范围约为<code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。</p><p><code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">float32</span>  = <span class="number">5.21</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">float64</span> = <span class="number">13.14</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>,a,<span class="string">&quot;b=&quot;</span>,b)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出：c=0.123</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="type">float64</span> = <span class="number">.123</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;c=&quot;</span>, c)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 科学计数法表示</span></span><br><span class="line">   d := <span class="number">5.1234e2</span></span><br><span class="line">   e := <span class="number">5.1234e-2</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;d=&quot;</span>,d,<span class="string">&quot;e=&quot;</span>,e)</span><br><span class="line">   <span class="comment">//输出：d= 512.34 e= 0.051234</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">complex64`和`complex128</span><br></pre></td></tr></table></figure><p>复数有实部和虚部，<code>complex64</code>的实部和虚部为32位，<code>complex128</code>的实部和虚部为64位。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">complex64</span> = <span class="number">5</span> + <span class="number">21i</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">complex128</span> = <span class="number">13</span> + <span class="number">14i</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>,a,<span class="string">&quot;b=&quot;</span>,b)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 计算复数的实部和虚部</span></span><br><span class="line">   realPart := <span class="built_in">real</span>(a)</span><br><span class="line">   imagPart := <span class="built_in">imag</span>(a)</span><br><span class="line">   fmt.Println(<span class="string">&quot;realPart=&quot;</span>,realPart,<span class="string">&quot;imagPart=&quot;</span>,imagPart)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔型数据只有true和false，且不能参与任何计算以及类型转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">bool</span>= <span class="literal">false</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>, a)</span><br><span class="line">   <span class="comment">//注意事项</span></span><br><span class="line">   <span class="comment">//1、bool类型占用存储空间是1个字节</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a的占用空间=&quot;</span>, unsafe.Sizeof(a))</span><br><span class="line">   <span class="comment">//2、bool类型只能取true或者false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>组成每个字符串的元素叫做字符，可以通过遍历或者单个获取字符串元素获得字符。 字符用<code>单引号&#39; &#39;</code>包裹起来</p><p>字符有两种类型</p><ul><li>byte：也是uint8类型，表示 ASCII 码的一个字符。</li><li>rune：也是int32类型，代表一个 Unicode 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">byte</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">   <span class="comment">// 输出对应的码值 a= 97</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>,a)</span><br><span class="line">   <span class="comment">// 输出对应的字符，a=a</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;a=%c\n&quot;</span>,a)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用rune表示中文，byte一个字节存不下</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">rune</span> = <span class="string">&#x27;中&#x27;</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;b=%c\n&quot;</span>,b)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 字符类型实际上存储的实对应码值，所以可以用整型存储</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="type">int</span> = <span class="string">&#x27;北&#x27;</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;c=%c c对应的码值=%d\n&quot;</span>, c, c)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>特性：一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 UTF-8 字符的一个序列</li><li>字符串转义符：</li></ul><table><thead><tr><th>转义</th><th>含义</th></tr></thead><tbody><tr><td>\r</td><td>回车符（返回行首）</td></tr><tr><td>\n</td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>&#39;</td><td>单引号</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>\</td><td>反斜杠自身</td></tr></tbody></table><ul><li>多行字符串</li></ul><p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code> &#96;&#96;字符</p><p>特点：反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><ul><li>修改字符串</li></ul><p>要修改字符串，需要先将其转换成<code>[]rune或[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 基本用法</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;我爱\ngo&quot;</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//多行字符串</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">string</span> =<span class="string">`</span></span><br><span class="line"><span class="string">      我爱go\n</span></span><br><span class="line"><span class="string">      hello world</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b=&quot;</span>,b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串拼接</span></span><br><span class="line">    <span class="comment">// 分行时需要将+保留在上一行</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="type">string</span> = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span> +</span><br><span class="line">      <span class="string">&quot;world&quot;</span> + <span class="string">&quot;hello&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;c=&quot;</span>, c)</span><br><span class="line">    <span class="comment">// c[0] = &#x27;c&#x27; // 错误，这里不能修改字符串的内容，go中的字符串是不可变的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改字符串</span></span><br><span class="line">    <span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    ans := []<span class="type">byte</span>(str)</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(ans)) <span class="comment">// 输出：Hello</span></span><br><span class="line">    </span><br><span class="line">    str = <span class="string">&quot;码斋&quot;</span></span><br><span class="line">    res := []<span class="type">rune</span>(str)</span><br><span class="line">    res[<span class="number">1</span>] = <span class="string">&#x27;神&#x27;</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(res)) <span class="comment">// 输出：码神</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>作用：指向其他变量，用于操作该变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       &amp;是取地址操作符</span></span><br><span class="line"><span class="comment">       *是取值操作符</span></span><br><span class="line"><span class="comment">       *数据类型是指针类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">521</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>, a) <span class="comment">// 输出： a=521</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 基本用法，指向变量a</span></span><br><span class="line">   <span class="keyword">var</span> p *<span class="type">int</span> = &amp;a</span><br><span class="line">   <span class="comment">// 修改后，变量a的值会发生变化</span></span><br><span class="line">   *p = <span class="number">1314</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>, a) <span class="comment">//输出：a=1314</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> ptr *<span class="type">int</span></span><br><span class="line">   <span class="comment">// *ptr = 10 // 错误，此时ptr是一个空指向，没有一个可用的内存地址供其操作</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用new函数提前在内存中申请一块内存，这样就获得了一个内存地址，就不会报错了</span></span><br><span class="line">   ptr = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">   *ptr = <span class="number">10</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;ptr=&quot;</span>, *ptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用</p><p>强制类型转换的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><h3 id="基本类型相互转换"><a href="#基本类型相互转换" class="headerlink" title="基本类型相互转换"></a>基本类型相互转换</h3><p>都使用强制类型转换</p><p>只有相同底层类型的变量之间可以进行相互转换，不同底层类型的变量相互转换时会引发编译错误（如bool转int）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 基本用法</span></span><br><span class="line">   <span class="comment">// 被转换的是变量存储的数据，变量本身的数据类型并没有改变。比如a的类型还是int32</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int32</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">float32</span> = <span class="type">float32</span>(a)</span><br><span class="line">   <span class="keyword">var</span> c <span class="type">int8</span> = <span class="type">int8</span>(a)</span><br><span class="line">   <span class="keyword">var</span> d <span class="type">int64</span> = <span class="type">int64</span>(a)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;a=%v b=%v c=%v d=%v\n&quot;</span>, a, b, c, d)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 高精度向低精度转换会损失精度</span></span><br><span class="line">   <span class="keyword">var</span> e <span class="type">int64</span> = <span class="number">999999</span></span><br><span class="line">   <span class="keyword">var</span> f <span class="type">int8</span> = <span class="type">int8</span>(e)</span><br><span class="line">   fmt.Println(<span class="string">&quot;f=&quot;</span>, f) <span class="comment">// 输出f=63</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本类型转换string"><a href="#基本类型转换string" class="headerlink" title="基本类型转换string"></a>基本类型转换string</h3><ul><li>方式一：<code>fmt.Sprintf</code></li><li>方式二：strconv包下的函数<code>strconv.Formatxxx</code></li><li>方式三：strconv包中的函数Itoa</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">float64</span> = <span class="number">5.21</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">   <span class="keyword">var</span> d <span class="type">byte</span> = <span class="string">&#x27;z&#x27;</span></span><br><span class="line">   <span class="keyword">var</span> str <span class="type">string</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式一</span></span><br><span class="line">   str = fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, a)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%v\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   str = fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, b)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%v\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   str = fmt.Sprintf(<span class="string">&quot;%t&quot;</span>, c)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%q\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   str = fmt.Sprintf(<span class="string">&quot;%c&quot;</span>, d)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%q\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式二</span></span><br><span class="line">   str = strconv.FormatInt(<span class="type">int64</span>(a), <span class="number">10</span>) <span class="comment">// 10表示10进制</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%q\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 说明: &#x27;f&#x27;格式  10：表示小数位保留10位 64：表示这个小数是float64</span></span><br><span class="line">   str = strconv.FormatFloat(b, <span class="string">&#x27;f&#x27;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%q\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   str = strconv.FormatBool(c)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%q\n&quot;</span>, str, str)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式三</span></span><br><span class="line">   <span class="keyword">var</span> e <span class="type">int64</span> = <span class="number">1314</span></span><br><span class="line">   str = strconv.Itoa(<span class="type">int</span>(e))</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str type %T str=%q\n&quot;</span>, str, str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string转换基本类型"><a href="#string转换基本类型" class="headerlink" title="string转换基本类型"></a>string转换基本类型</h3><p>使用strconv.Parsexxx函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;1314&quot;</span></span><br><span class="line">   <span class="comment">// 转int</span></span><br><span class="line">   <span class="comment">// 只想获取到value int，不想获取err，所以使用_忽略</span></span><br><span class="line">   a, _ := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">64</span>) <span class="comment">// 10是十进制，64返回的是int64</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;a type %T=%v\n&quot;</span>, a, a)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 转float</span></span><br><span class="line">   str = <span class="string">&quot;13.14&quot;</span></span><br><span class="line">   b, _ := strconv.ParseFloat(str, <span class="number">64</span>) <span class="comment">// 64返回的是float64</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;b type %T=%v\n&quot;</span>, b, b)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 转bool</span></span><br><span class="line">   str = <span class="string">&quot;true&quot;</span></span><br><span class="line">   c, _ := strconv.ParseBool(str)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;c type %T=%v\n&quot;</span>, c, c)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当string不能转换为相应的基本数据类型时，会有默认值</span></span><br><span class="line">   str = <span class="string">&quot;1234&quot;</span></span><br><span class="line">   d, _ := strconv.ParseBool(str)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;d type %T=%v\n&quot;</span>, d, d) <span class="comment">// 输出： d type bool=false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>用于数据类型之间的运算操作</p><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>相加</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>相乘</td></tr><tr><td>&#x2F;</td><td>相除</td></tr><tr><td>%</td><td>求余</td></tr></tbody></table><p> 注：++（自增）和–（自减）在Go语言中是单独的语句，并不是运算符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 加法</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">   num := a + b</span><br><span class="line">   fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 减法</span></span><br><span class="line">   num = a - b</span><br><span class="line">   fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 乘法</span></span><br><span class="line">   num = a * b</span><br><span class="line">   fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 除法</span></span><br><span class="line">   <span class="comment">// 如果运算的数都是整数，那么除后，去掉小数部分，保留整数部分</span></span><br><span class="line">   fmt.Println(<span class="number">10</span>/<span class="number">4</span>) <span class="comment">// 输出：2</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="type">float32</span> = <span class="number">10</span>/<span class="number">4</span></span><br><span class="line">   fmt.Println(c) <span class="comment">// 输出：2</span></span><br><span class="line">   <span class="comment">// 希望保留小数部分，则需要有浮点数参与运算</span></span><br><span class="line">   <span class="keyword">var</span> d <span class="type">float32</span> = <span class="number">10.0</span> / <span class="number">4</span></span><br><span class="line">   fmt.Println(d)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 模运算</span></span><br><span class="line">   <span class="comment">// 公式：a%b = a - a / b * b</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;10%3=&quot;</span>, <span class="number">10</span>%<span class="number">3</span>) <span class="comment">// 输出 1</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;-10%3=&quot;</span>, <span class="number">-10</span>%<span class="number">3</span>) <span class="comment">// 输出 -1</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;10%-3=&quot;</span>, <span class="number">10</span>%<span class="number">-3</span>) <span class="comment">// 输出 1</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;-10%-3&quot;</span>, <span class="number">-10</span>%<span class="number">-3</span>) <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// ++和--使用</span></span><br><span class="line">   <span class="comment">// 只有后++，后--</span></span><br><span class="line">   <span class="keyword">var</span> e <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">   e++</span><br><span class="line">   fmt.Println(<span class="string">&quot;e=&quot;</span>, e) <span class="comment">// 输出 11</span></span><br><span class="line">   e--</span><br><span class="line">   fmt.Println(<span class="string">&quot;e=&quot;</span>, e) <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>判断两个变量的大小关系</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td>!&#x3D;</td><td>检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td>&gt;</td><td>检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&gt;&#x3D;</td><td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;</td><td>检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;&#x3D;</td><td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">9</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">8</span></span><br><span class="line">   fmt.Println(a == b) <span class="comment">// false</span></span><br><span class="line">   fmt.Println(a != b) <span class="comment">// true</span></span><br><span class="line">   fmt.Println(a &gt; b) <span class="comment">// true</span></span><br><span class="line">   fmt.Println(a &gt;= b) <span class="comment">// true</span></span><br><span class="line">   fmt.Println(a &lt; b) <span class="comment">// false</span></span><br><span class="line">   fmt.Println(a &lt;= b) <span class="comment">// false</span></span><br><span class="line">   flag := a &gt; b</span><br><span class="line">   fmt.Println(<span class="string">&quot;flag=&quot;</span>, flag) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>用于两个变量或表达式的逻辑关系</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td>ll</td><td>逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td></tr><tr><td>!</td><td>逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;test...&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">27</span></span><br><span class="line">   <span class="comment">// 逻辑与</span></span><br><span class="line">   <span class="keyword">if</span> a &gt; <span class="number">18</span> &amp;&amp; a &lt; <span class="number">30</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;ok1&quot;</span>) <span class="comment">// 执行</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 逻辑或</span></span><br><span class="line">   <span class="keyword">if</span> a &gt; <span class="number">18</span> || a &lt; <span class="number">30</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;ok2&quot;</span>) <span class="comment">// 执行</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 逻辑非</span></span><br><span class="line">   <span class="keyword">if</span> !(a &lt; <span class="number">18</span>) &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;ok3&quot;</span>) <span class="comment">// 执行</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 短路与</span></span><br><span class="line">   <span class="comment">// 因为a&lt;18为false，因此后面的test()就不执行</span></span><br><span class="line">   <span class="keyword">if</span> a &lt; <span class="number">18</span> &amp;&amp; test() &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;短路与&quot;</span>) <span class="comment">// 不执行</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 短路或</span></span><br><span class="line">   <span class="comment">// 因为a&gt;18为true，因此后面的test()就不执行</span></span><br><span class="line">   <span class="keyword">if</span> a &gt; <span class="number">18</span> || test() &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;短路或&quot;</span>) <span class="comment">//执行</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>将一个变量赋值给另一个变量</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+&#x3D;</td><td>相加后再赋值</td></tr><tr><td>-&#x3D;</td><td>相减后再赋值</td></tr><tr><td>*&#x3D;</td><td>相乘后再赋值</td></tr><tr><td>&#x2F;&#x3D;</td><td>相除后再赋值</td></tr><tr><td>%&#x3D;</td><td>求余后再赋值</td></tr><tr><td>&lt;&lt;&#x3D;</td><td>左移后赋值</td></tr><tr><td>&gt;&gt;&#x3D;</td><td>右移后赋值</td></tr><tr><td>&amp;&#x3D;</td><td>按位与后赋值</td></tr><tr><td>l&#x3D;</td><td>按位或后赋值</td></tr><tr><td>^&#x3D;</td><td>按位异或后赋值</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 赋值</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span>  = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 复合赋值，其余复合赋值运算符类似</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">   a += b</span><br><span class="line">   fmt.Println(<span class="string">&quot;a=&quot;</span>, a) <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 交换两个数</span></span><br><span class="line">   <span class="comment">// 方式1</span></span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="type">int</span> = <span class="number">1</span></span><br><span class="line">   <span class="keyword">var</span> d <span class="type">int</span> = <span class="number">2</span></span><br><span class="line">   temp = c</span><br><span class="line">   c = d</span><br><span class="line">   d = temp</span><br><span class="line">   fmt.Println(<span class="string">&quot;c=&quot;</span>, c, <span class="string">&quot;d=&quot;</span>, d) <span class="comment">// 输出：c=2,d=1</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//方式2</span></span><br><span class="line">   c = c+d</span><br><span class="line">   d = c-d</span><br><span class="line">   c = c-d</span><br><span class="line">   fmt.Println(<span class="string">&quot;c=&quot;</span>, c, <span class="string">&quot;d=&quot;</span>, d) <span class="comment">// 输出：c=1,d=2</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式3</span></span><br><span class="line">   c, d = d, c</span><br><span class="line">   fmt.Println(<span class="string">&quot;c=&quot;</span>, c, <span class="string">&quot;d=&quot;</span>, d) <span class="comment">// 输出：c=2,d=1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>二进制：01组成</p><p>八进制：0-7，满8进1，以数字0开头表示</p><p>十六进制：0-9及A-F，满16进1，以0x或0X开头表示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">        <span class="comment">//二进制输出，直接输出是十进制</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, i)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//八进制：0-7，满8进1，以数字0开头表示</span></span><br><span class="line">        <span class="keyword">var</span> j <span class="type">int</span> = <span class="number">011</span> <span class="comment">//011=8+1=9</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;j=&quot;</span>, j)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//0-9及A-F，满16进1，以0x或0X开头表示</span></span><br><span class="line">        <span class="keyword">var</span> k <span class="type">int</span> = <span class="number">0x11</span> <span class="comment">//0x11=16+1=17</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;k=&quot;</span>, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>位运算符对整数在内存中的二进制位进行操作。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>参与运算的两数各对应的二进位相与。（两位均为1才为1）</td></tr><tr><td>l</td><td>参与运算的两数各对应的二进位相或。（两位有一个为1就为1）</td></tr><tr><td>^</td><td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1）</td></tr><tr><td>&lt;&lt;</td><td>左移n位就是乘以2的n次方。“a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td>&gt;&gt;</td><td>右移n位就是除以2的n次方。“a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1</span> <span class="comment">// 0001</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">3</span> <span class="comment">// 0011</span></span><br><span class="line">   <span class="comment">// 与</span></span><br><span class="line">   fmt.Println(a&amp;b) <span class="comment">// 1</span></span><br><span class="line">   <span class="comment">// 或</span></span><br><span class="line">   fmt.Println(a|b) <span class="comment">// 3</span></span><br><span class="line">   <span class="comment">// 异或</span></span><br><span class="line">   fmt.Println(a^b) <span class="comment">// 2</span></span><br><span class="line">   <span class="comment">//左移</span></span><br><span class="line">   fmt.Println(a&lt;&lt;b) <span class="comment">// 8</span></span><br><span class="line">   <span class="comment">//右移</span></span><br><span class="line">   fmt.Println(a&gt;&gt;b) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>go没有三元运算符</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//传统的三元运算</span></span><br><span class="line">   <span class="comment">//n=i&gt;j?i:j</span></span><br><span class="line">   <span class="comment">//在golang中是没有这个传统三元运算的</span></span><br><span class="line">   <span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">   <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">   <span class="keyword">var</span> j <span class="type">int</span> = <span class="number">12</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">      n = i</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      n = j</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;n=&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>变量输入</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">   <span class="keyword">var</span> age <span class="type">byte</span></span><br><span class="line">   <span class="keyword">var</span> sal <span class="type">float32</span></span><br><span class="line">   <span class="keyword">var</span> isPass <span class="type">bool</span></span><br><span class="line">   <span class="comment">// 方式1 fmt.Scanln</span></span><br><span class="line">   <span class="comment">// 当程序执行到fmt.Scanln(&amp;name)，程序会停止在这里，等待用户输入，并回车</span></span><br><span class="line">   fmt.Scanln(&amp;name)</span><br><span class="line">   fmt.Scanln(&amp;age)</span><br><span class="line">   fmt.Scanln(&amp;sal)</span><br><span class="line">   fmt.Scanln(&amp;isPass)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;名字是%v\n 年龄是%v\n 薪水是%v\n 是否通过考试%v\n&quot;</span>, name, age, sal, isPass)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 方式2 fmt.Scanf，可以按指定的格式输入</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;请输入你的姓名，年龄，薪水，是否通过考试，使用空格隔开&quot;</span>)</span><br><span class="line">   fmt.Scanf(<span class="string">&quot;%s %d %f %t&quot;</span>, &amp;name, &amp;age, &amp;sal, &amp;isPass)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;名字是%v\n 年龄是%v\n 薪水是%v\n 是否通过考试%v\n&quot;</span>, name, age, sal, isPass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="条件语句if"><a href="#条件语句if" class="headerlink" title="条件语句if"></a>条件语句if</h3><p>条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。</p><ul><li>单分支条件语句</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">18</span></span><br><span class="line">   <span class="comment">// 单分支</span></span><br><span class="line">   <span class="keyword">if</span> a &gt; <span class="number">18</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;a不大于18&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 在go中，支持在if中直接定义一个变量</span></span><br><span class="line">   <span class="keyword">if</span> b := <span class="number">20</span>; b &gt; <span class="number">18</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;b大于18&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双分支条件语句</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">   <span class="comment">//else的位置只能这样，不能换行</span></span><br><span class="line">   <span class="keyword">if</span> a &gt; <span class="number">18</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;大于18...&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;不大于18&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多分支条件语句</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">   <span class="comment">//多分支判断</span></span><br><span class="line">   <span class="keyword">if</span> a == <span class="number">100</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">80</span> &amp;&amp; score == <span class="number">99</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;呵呵&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt;= <span class="number">60</span> &amp;&amp; score &lt;= <span class="number">80</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;嘿嘿&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;嗯嗯&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>嵌套条件语句</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> a &lt;= <span class="number">8</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">      <span class="keyword">if</span> b == <span class="number">10</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;嗯嗯&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;嘿嘿&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件语句switch"><a href="#条件语句switch" class="headerlink" title="条件语句switch"></a>条件语句switch</h3><p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止。特点：switch 分支表达式可以是任意类型，不限于常量。可省略 break，默认自动终止</p><p>细节：</p><p>1、switch分支不需要break，匹配到执行代码块，执行完退出switch</p><p>2、case后面可以有多个表达式，用逗号隔开</p><p>3、后面接的表达式可以是常量，变量，带返回值的函数等</p><p>4、case后的各个表达式的值的数据类型要与switch后的表达式的数据类型一致</p><p>5、case后面表达式如果是常量值，则要求不能重复</p><p>6、default语句不是必须的</p><p>7、switch后也可以不带表达式，类似if—else分支来使用</p><p>8、case中可以对范围进行判断</p><p>9、switch后也可以直接声明&#x2F;定义一个变量，分号结束，不推荐</p><p>10、switch穿透 - fallthrough，如果在case语句块后增加fallthrough，则会继续执行下一个case，也叫switch穿透</p><p>11、Type Switch：switch语句还可以被用于type-switch来判断某个interface变量中实际指向的变量类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 基本用法</span></span><br><span class="line">   <span class="keyword">var</span> age <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> age == <span class="number">10</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;age==10&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> age == <span class="number">20</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;age==20&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;没有匹配到&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//8、case中可以对范围进行判断</span></span><br><span class="line">   <span class="keyword">var</span> score <span class="type">int</span> = <span class="number">90</span></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> score &gt; <span class="number">90</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;成绩优秀&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> score &gt;= <span class="number">70</span> &amp;&amp; score &lt;= <span class="number">90</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;成绩优良&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">70</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;成绩及格&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;不及格&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//9、switch后也可以直接声明/定义一个变量，分号结束，不推荐</span></span><br><span class="line">   <span class="keyword">switch</span> grade := <span class="number">90</span>; &#123;</span><br><span class="line">      <span class="keyword">case</span> grade &gt; <span class="number">90</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;成绩优秀&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> grade &gt;= <span class="number">70</span> &amp;&amp; grade &lt;= <span class="number">90</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;成绩优良&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> grade &gt;= <span class="number">60</span> &amp;&amp; grade &lt; <span class="number">70</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;成绩及格&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;不及格&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//10、switch穿透 - fallthrough，如果在case语句块后增加fallthrough，则会继续执行下一个case，也叫switch穿透</span></span><br><span class="line">   <span class="keyword">var</span> num <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">      <span class="keyword">switch</span> num &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;ok1&quot;</span>) <span class="comment">// 执行</span></span><br><span class="line">         <span class="keyword">fallthrough</span> <span class="comment">//默认只能穿透一层</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;ok2&quot;</span>) <span class="comment">// 执行</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">30</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;ok3&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;没有匹配到&quot;</span>)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//11、Type Switch：switch语句还可以被用于type-switch来判断某个interface变量中实际指向的变量类型</span></span><br><span class="line">   <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">var</span> y = <span class="number">10.0</span></span><br><span class="line">   x = y</span><br><span class="line">   <span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;x的类型%T\n&quot;</span>, i)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;x是int型&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;x是float64型&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">float64</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;x是func(int)型&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">bool</span>, <span class="type">string</span>:</span><br><span class="line">         fmt.Println(<span class="string">&quot;x是bool或string型&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;未知型&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件语句select"><a href="#条件语句select" class="headerlink" title="条件语句select"></a>条件语句select</h3><h3 id="循环语句for"><a href="#循环语句for" class="headerlink" title="循环语句for"></a>循环语句for</h3><p>for循环是一个循环控制结构，可以执行指定次数的循环。</p><p>语法：</p><p>Go语言的For循环有3种形式，只有其中的一种使用分号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">三种形式：</span><br><span class="line">for init; condition; post &#123; &#125;</span><br><span class="line">for condition &#123; &#125;</span><br><span class="line">for &#123; &#125;</span><br><span class="line"></span><br><span class="line">init： 一般为赋值表达式，给控制变量赋初值；</span><br><span class="line">condition： 关系表达式或逻辑表达式，循环控制条件；</span><br><span class="line">post： 一般为赋值表达式，给控制变量增量或减量。</span><br><span class="line">for语句执行过程如下：</span><br><span class="line">①先对表达式 init 赋初值；</span><br><span class="line">②判别赋值表达式 init 是否满足给定 condition 条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   // 第一种形式</span><br><span class="line">   for i := 0; i &lt; 10 ; i++ &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 第二种形式</span><br><span class="line">   // 类似于while循环，go中没有while和do-while</span><br><span class="line">   var i int = 0</span><br><span class="line">   for i &lt; 10 &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">      i++</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 第三种形式</span><br><span class="line">   // 死循环</span><br><span class="line">   for true &#123;</span><br><span class="line">      fmt.Println(&quot;死循环&quot;)</span><br><span class="line">      break</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 循环嵌套</span><br><span class="line">   for i := 0; i &lt; 5 ; i++ &#123;</span><br><span class="line">      for j := 0; j &lt; 5; j++ &#123;</span><br><span class="line">         fmt.Println(&quot;i=&quot;, i, &quot;j=&quot;, j)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环语句range"><a href="#循环语句range" class="headerlink" title="循环语句range"></a>循环语句range</h3><p>Golang range类似迭代器操作，返回 (索引, 值) 或 (键, 值)。</p><p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">   <span class="comment">// 忽略 2nd value，支持 string/array/slice/map。</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">      <span class="built_in">println</span>(s[i])</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 忽略 index。</span></span><br><span class="line">   <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">      <span class="built_in">println</span>(c)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 忽略全部返回值，仅迭代。</span></span><br><span class="line">   <span class="keyword">for</span> <span class="keyword">range</span> s &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">   <span class="comment">// 返回 (key, value)。</span></span><br><span class="line">   <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">      <span class="built_in">println</span>(k, v)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环控制语句goto、break、continue、return"><a href="#循环控制语句goto、break、continue、return" class="headerlink" title="循环控制语句goto、break、continue、return"></a>循环控制语句goto、break、continue、return</h3><p>循环控制语句可以控制循环体内语句的执行过程。</p><ul><li>goto 语句：通过<code>标签</code>进行代码间的无条件跳转，同时 goto 语句在快速跳出循环、避免重复退出上也有一定的帮助，使用 goto 语句能简化一些代码的实现过程。</li><li>break 语句：可以结束 for、switch 和 select 的代码块，另外 break 语句还可以在语句后面添加<code>标签</code>，表示退出某个标签对应的代码块，<code>标签</code>要求必须定义在对应的 <code>for</code>、<code>switch</code> 和 <code>select </code>的代码块上。</li><li>continue 语句：可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用，在 continue 语句后添加<code>标签</code>时，表示开始<code>标签对应的循环</code></li><li>return语句：结束当前函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> count <span class="type">int</span> = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      <span class="comment">// i等于count时，使用break退出该循环</span></span><br><span class="line">      <span class="keyword">if</span> i == count &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;退出for循环&quot;</span>)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块</span></span><br><span class="line">   <span class="comment">// break默认会跳出最近的for循环</span></span><br><span class="line">   <span class="comment">// break后面可以指定标签，跳出标签对应的for循环</span></span><br><span class="line">label2:</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">      <span class="comment">// label1: //设置一个标签</span></span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> j == <span class="number">2</span> &#123; <span class="comment">// j==2的时，跳出标签label2指示的循环</span></span><br><span class="line">            <span class="keyword">break</span> label2</span><br><span class="line">         &#125;</span><br><span class="line">         fmt.Println(<span class="string">&quot;j=&quot;</span>, j)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// continue使用</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">      <span class="comment">// i为偶数时直接跳过，进入下一次循环</span></span><br><span class="line">      <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>&#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="string">&quot;奇数是&quot;</span>, i)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// goto和return</span></span><br><span class="line">   <span class="keyword">goto</span> label3</span><br><span class="line">   fmt.Println(<span class="string">&quot;ok1&quot;</span>) <span class="comment">// 不执行</span></span><br><span class="line">label3:</span><br><span class="line">   fmt.Println(<span class="string">&quot;ok3&quot;</span>) <span class="comment">// 执行</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//return使用在方法或者函数中，表示跳出所在方法或函数</span></span><br><span class="line">   <span class="comment">//如果return是在普通的函数，则表示跳出该函数，即不再执行函数中return后面代码，也可以理解成终止函数</span></span><br><span class="line">   <span class="comment">//如果return是在main函数，表示终止main函数，也就是说终止程序</span></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;re1&quot;</span>) <span class="comment">// 不执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h1 id="结构体和接口"><a href="#结构体和接口" class="headerlink" title="结构体和接口"></a>结构体和接口</h1><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><h1 id="defer和time"><a href="#defer和time" class="headerlink" title="defer和time"></a>defer和time</h1><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股文</title>
      <link href="/2024/04/10/C++/C-%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/04/10/C++/C-%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h2 id="简述下C-语言的特点"><a href="#简述下C-语言的特点" class="headerlink" title="简述下C++语言的特点"></a>简述下C++语言的特点</h2><ol><li>引入了面向对象的机制，同时兼容了C语言</li><li>C++有三大特性：封装、继承、多态</li><li>C++可复用性高，引入了模板</li></ol><h2 id="C和C-有什么区别"><a href="#C和C-有什么区别" class="headerlink" title="C和C++有什么区别"></a>C和C++有什么区别</h2><ol><li>C++是面向对象的语言，而C是面向过程的语言；</li><li>C++引入new&#x2F;delete运算符，取代了C中的malloc&#x2F;free库函数；</li><li>C++引入引用的概念，而C中没有；</li><li>C++引入类的概念，而C中没有；</li><li>C++引入函数重载的特性，而C中没有</li></ol><h2 id="说说include头文件的顺序以及双引号””和尖括号的区别"><a href="#说说include头文件的顺序以及双引号””和尖括号的区别" class="headerlink" title="说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别"></a>说说include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h2><ol><li>尖括号&lt;&gt;的头文件是系统文件，双引号””的头文件是自定义文件。</li><li>编译器预处理阶段查找头文件的路径不一样。</li></ol><h2 id="说一说extern-“C”"><a href="#说一说extern-“C”" class="headerlink" title="说一说extern “C”"></a>说一说extern “C”</h2><ol><li>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。</li><li>加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。</li></ol><h2 id="C-编译时和C有什么不同？"><a href="#C-编译时和C有什么不同？" class="headerlink" title="C++编译时和C有什么不同？"></a>C++编译时和C有什么不同？</h2><ol><li>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；</li><li>而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</li></ol><h2 id="简述C-从代码到可执行二进制文件的过程"><a href="#简述C-从代码到可执行二进制文件的过程" class="headerlink" title="简述C++从代码到可执行二进制文件的过程"></a>简述C++从代码到可执行二进制文件的过程</h2><p>一个C++程序从源码到执行文件，有四个过程，预编译、编译、汇编、链接。<br>预编译：这个过程主要的处理操作如下：<br>（1）  将所有的#define删除，并且展开所有的宏定义<br>（2）  处理所有的条件预编译指令，如#if、#ifdef<br>（3）  处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。<br>（4）  过滤所有的注释<br>（5）  添加行号和文件名标识。<br>编译：这个过程主要的处理操作如下：<br>（1）  词法分析：将源代码的字符序列分割成一系列的记号。<br>（2）  语法分析：对记号进行语法分析，产生语法树。<br>（3）  语义分析：判断表达式是否有意义。<br>（4）  代码优化：<br>（5）  目标代码生成：生成汇编代码。<br>（6）  目标代码优化：<br>汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。<br>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。<br>链接分为静态链接和动态链接。<br>静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。<br>而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</p><h2 id="静态链接和动态链接有什么区别？"><a href="#静态链接和动态链接有什么区别？" class="headerlink" title="静态链接和动态链接有什么区别？"></a>静态链接和动态链接有什么区别？</h2><ol><li>静态链接是在编译链接时直接将需要的执行代码拷贝到调用处；<br>优点在于程序在发布时不需要依赖库，可以独立执行，缺点在于程序的体积会相对较大，而且如果静态库更新之后，所有可执行文件需要重新链接；</li><li>动态链接是在编译时不直接拷贝执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接；<br>优点在于多个程序可以共享同一个动态库，节省资源；<br>缺点在于由于运行时加载，可能影响程序的前期执行性能。</li></ol><h2 id="说说static关键字的作用"><a href="#说说static关键字的作用" class="headerlink" title="说说static关键字的作用"></a>说说static关键字的作用</h2><p>static用于声明变量的存储期和可见性</p><ol><li>修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；</li><li>修饰全局变量时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的；</li><li>修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突；</li><li>修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加static；</li><li>修饰成员函数时，该函数不接受this指针，只能访问类的静态成员；不需要实例化对象即可访问。</li></ol><h2 id="C语言的关键字static和C-的关键字static有什么区别"><a href="#C语言的关键字static和C-的关键字static有什么区别" class="headerlink" title="C语言的关键字static和C++的关键字static有什么区别"></a>C语言的关键字static和C++的关键字static有什么区别</h2><p>在 C 中 static 用来修饰局部静态变量和外部静态变量、函数。而 C++中除了上述功能外，还用来定义类的成员变量和函数。即静态成员和静态成员函数。<br>「注意」：编程时 static 的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而 C++的静态成员则可以在多个对象实例间进行通信，传递信息。</p><h2 id="说说数组和指针的区别"><a href="#说说数组和指针的区别" class="headerlink" title="说说数组和指针的区别"></a>说说数组和指针的区别</h2><ol><li>概念：<br> 数组：数组是用于存储多个类型相同的数据集合。数组名是首元素的地址<br> 指针：指针相当于一个变量，但是和其他变量不一样，它存放的是其他变量在内存中的地址。指针名指向了内存的首地址。</li><li>区别：<br> 赋值：同类型指针变量可以相互赋值；数组只能一个一个元素的赋值或拷贝<br> 求sizeof：无论指针的类型是什么，sizeof的大小要么是4，要么是8；数组所占存储空间的内存大小：sizeof(数组名)&#x2F;sizeof(数据类型)</li></ol><p>int a[3][4];<br>int (<em>p)[4];  &#x2F;&#x2F;该语句是定义一个数组指针，指向含4个元素的一维数组<br>p &#x3D; a;        &#x2F;&#x2F;将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]<br>p++;          &#x2F;&#x2F;该语句执行过后，也就是p&#x3D;p+1；p跨过行a[0][]指向了行a[1][]<br>              &#x2F;&#x2F;所以数组指针也称指向一维数组的指针，亦称行指针。<br>&#x2F;&#x2F;访问数组中第i行j列的一个元素，有几种操作方式：<br>&#x2F;&#x2F;</em>(p[i]+j)、*(<em>(p+i)+j)、(</em>(p+i))[j]、p[i][j]。其中，优先级：()&gt;[]&gt;*。<br>&#x2F;&#x2F;这几种操作方式都是合法的。</p><h2 id="简述指针常量与常量指针的区别"><a href="#简述指针常量与常量指针的区别" class="headerlink" title="简述指针常量与常量指针的区别"></a>简述指针常量与常量指针的区别</h2><ol><li>指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。</li><li>指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。<br>「注意」：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。</li></ol><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ol><li>指针有自己的一块空间，而引用只是一个别名；</li><li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li><li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li><li>可以有const指针，但是没有引用常量；（具体解释看评论区）</li><li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li><li>指针可以有多级指针（**p），而引用止于一级；</li><li>指针和引用使用++运算符的意义不一样；</li><li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li></ol><h2 id="什么是函数指针"><a href="#什么是函数指针" class="headerlink" title="什么是函数指针"></a>什么是函数指针</h2><ol><li>概念：函数指针就是指向函数的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。<br>定义形式如下：<br>int func(int a); int (*f)(int a); f &#x3D; &func;</li><li>函数指针的应用场景：回调（callback）。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫Callback。</li></ol><h2 id="说说什么是野指针，怎么产生的，如何避免？"><a href="#说说什么是野指针，怎么产生的，如何避免？" class="headerlink" title="说说什么是野指针，怎么产生的，如何避免？"></a>说说什么是野指针，怎么产生的，如何避免？</h2><p>概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）<br>产生原因：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。<br>避免办法：<br>（1）初始化置NULL<br>（2）申请内存后判空<br>（3）指针释放后置NULL<br>（4）使用智能指针</p><h2 id="悬挂指针与野指针有什么区别？"><a href="#悬挂指针与野指针有什么区别？" class="headerlink" title="悬挂指针与野指针有什么区别？"></a>悬挂指针与野指针有什么区别？</h2><ol><li>悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针；</li><li>野指针：未初始化的指针被称为野指针。</li></ol><h2 id="全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？"><a href="#全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？" class="headerlink" title="全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？"></a>全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？</h2><ol><li>全局变量是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束（在程序结束时所占内存释放）；</li><li>而局部变量存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函数调用完毕），局部变量消失，所占据的内存释放。</li><li>操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。</li></ol><h2 id="说说内联函数和宏函数的区别"><a href="#说说内联函数和宏函数的区别" class="headerlink" title="说说内联函数和宏函数的区别"></a>说说内联函数和宏函数的区别</h2><ol><li>宏定义不是函数，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；而内联函数本质上是一个函数，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。</li><li>宏函数是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；而内联函数则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率</li><li>宏定义是没有类型检查的，无论对还是错都是直接替换；而内联函数在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等</li></ol><h2 id="对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？"><a href="#对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？" class="headerlink" title="对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？"></a>对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？</h2><p>应该使用inline内联函数，即编译器将inline内联函数内的代码替换到函数被调用的地方。<br>优点：</p><ol><li>在内联函数被调用的地方进行代码展开，省去函数调用的时间，从而提高程序运行效率；</li><li>相比于宏函数，内联函数在代码展开时，编译器会进行语法安全检查或数据类型转换，使用更加安全；<br>缺点：</li><li>代码膨胀，产生更多的开销；</li><li>如果内联函数内代码块的执行时间比调用时间长得多，那么效率的提升并没有那么大；</li><li>如果修改内联函数，那么所有调用该函数的代码文件都需要重新编译；</li><li>内联声明只是建议，是否内联由编译器决定，所以实际并不可控。</li></ol><h2 id="说说运算符i-和-i的区别"><a href="#说说运算符i-和-i的区别" class="headerlink" title="说说运算符i++和++i的区别"></a>说说运算符i++和++i的区别</h2><ol><li>赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。</li><li>效率不同：后置++执行速度比前置的慢。</li><li>i++ 不能作为左值，而++i 可以</li><li>两者都不是原子操作。（原子操作是指一个不受其他操作影响的操作任务单元）</li></ol><h2 id="C-的顶层const和底层const-？"><a href="#C-的顶层const和底层const-？" class="headerlink" title="C++的顶层const和底层const ？"></a>C++的顶层const和底层const ？</h2><ol><li>底层const是代表指针的指向可以改变，指向的值不可以改变；（常量指针）</li><li>顶层const是代表指针的指向不可改变，指向的值可以改变。（指向不可改变）；（指针常量）</li></ol><h2 id="说说const和define的区别"><a href="#说说const和define的区别" class="headerlink" title="说说const和define的区别"></a>说说const和define的区别</h2><ol><li>const生效于编译的阶段；define生效于预处理阶段。</li><li>const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。</li><li>const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。</li><li>定义域不同：#define宏不受定义域限制，而const常量只在定义域内有效。</li></ol><h2 id="typedef-和define-有什么区别"><a href="#typedef-和define-有什么区别" class="headerlink" title="typedef 和define 有什么区别"></a>typedef 和define 有什么区别</h2><ul><li>用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义 常量，以及书写复杂使用频繁的宏。</li><li>执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。</li><li>作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在define 声明后的引用 都是正确的。</li><li>对指针的操作不同：typedef 和define 定义的指针时有很大的区别。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTR_INT int*  </span></span><br><span class="line">PTR_INT p, q; <span class="comment">// 这实际上等价于 int* p, q; p是int*类型，q是int类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* PTR_INT;  </span><br><span class="line">PTR_INT p, q; <span class="comment">// 这里p和q都是int*类型的指针</span></span><br></pre></td></tr></table></figure>「注意」：typedef 定义是语句，因为句尾要加上分号。而define 不是语句，千万不能在句尾加分号。</li></ul><h2 id="说说C-中函数指针和指针函数的区别"><a href="#说说C-中函数指针和指针函数的区别" class="headerlink" title="说说C++中函数指针和指针函数的区别"></a>说说C++中函数指针和指针函数的区别</h2><ol><li>指针函数本质是一个函数，其返回值为指针。</li><li>函数指针本质是一个指针，其指向一个函数。</li></ol><h2 id="变量的声明和定义有什么区别"><a href="#变量的声明和定义有什么区别" class="headerlink" title="变量的声明和定义有什么区别"></a>变量的声明和定义有什么区别</h2><ol><li>变量的定义为变量分配地址和存储空间，</li><li>变量的声明不分配地址。一个变量可以在多个地方声明， 但是只在一个地方定义。</li><li>加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。<br>说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。</li></ol><h2 id="简述-ifdef、-else、-endif和-ifndef的作用"><a href="#简述-ifdef、-else、-endif和-ifndef的作用" class="headerlink" title="简述#ifdef、#else、#endif和#ifndef的作用"></a>简述#ifdef、#else、#endif和#ifndef的作用</h2><ol><li>利用#ifdef、#endif将某程序功能模块包括进去，以向特定用户提供该功能。在不需要时用户可轻易将其屏蔽。</li><li>在子程序前加上标记，以便于追踪和调试。<br>条件编译就是为了实现在满足一定条件时编译某一组语句，而再不满足条件时编译另一组语句！<br>结构体可以直接赋值吗<br>声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针“成员”时一定要小心。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;  </span><br><span class="line">    <span class="type">int</span> x;  </span><br><span class="line">    <span class="type">int</span> y;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Point p1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;  </span><br><span class="line">    Point p2;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 在C++中，可以直接对整个结构体进行赋值  </span></span><br><span class="line">    p2 = p1;  </span><br><span class="line">      </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2.x = &quot;</span> &lt;&lt; p2.x &lt;&lt; <span class="string">&quot;, p2.y = &quot;</span> &lt;&lt; p2.y &lt;&lt; std::endl;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>「注意」：当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作。因此在释放前一定要确保其他指针不再使用这段内存空间。</li></ol><h2 id="sizeof-和strlen-的区别"><a href="#sizeof-和strlen-的区别" class="headerlink" title="sizeof 和strlen 的区别"></a>sizeof 和strlen 的区别</h2><ol><li>sizeof是一个操作符，strlen是库函数。</li><li>sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0’的字符串作参数。</li><li>编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。</li><li>数组做sizeof的参数不退化，传递给strlen就退化为指针了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];  </span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">sizeof</span>(arr); <span class="comment">// size 将会是 10 * sizeof(int)，即数组整个大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;  </span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(str); <span class="comment">// len 将会是 5，因为 &quot;Hello&quot; 有5个字符（不包括结尾的 &#x27;\0&#x27;）</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="一个参数可以既是const又是volatile吗"><a href="#一个参数可以既是const又是volatile吗" class="headerlink" title="一个参数可以既是const又是volatile吗"></a>一个参数可以既是const又是volatile吗</h2><p>可以，用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄存器读取它的备份。<br>注意：在此一定要注意const的意思，const只是不允许程序中的代码改变某一变量，其在编译期发挥作用，它并没有实际地禁止某段内存的读写特性。</p><h2 id="简述strcpy、sprintf-与memcpy-的区别"><a href="#简述strcpy、sprintf-与memcpy-的区别" class="headerlink" title="简述strcpy、sprintf 与memcpy 的区别"></a>简述strcpy、sprintf 与memcpy 的区别</h2><ol><li>操作对象不同，strcpy 的两个操作对象均为字符串，sprintf 的操作源对象可以是多种数据类型， 目的操作对象是字符串，memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</li><li>执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。</li><li>实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字符串的转化，memcpy 主要是内存块间的拷贝。<br>「注意」：strcpy、sprintf 与memcpy 都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来 选择合适的函数实现拷贝功能。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;  </span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];  </span><br><span class="line">      </span><br><span class="line">    <span class="built_in">strcpy</span>(dest, src);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copied string: %s\n&quot;</span>, dest);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">50</span>];  </span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;  </span><br><span class="line">    <span class="type">float</span> b = <span class="number">20.5</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;Integer: %d, Float: %.2f&quot;</span>, a, b);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Formatted string: %s\n&quot;</span>, buffer);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;  </span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];  </span><br><span class="line">      </span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="number">7</span>);  <span class="comment">// 只复制前7个字符  </span></span><br><span class="line">    dest[<span class="number">7</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 添加终止字符  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copied bytes: %s\n&quot;</span>, dest);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="请解析-void-0-的含义"><a href="#请解析-void-0-的含义" class="headerlink" title="请解析((void ()( ) )0)( )的含义"></a>请解析((void ()( ) )0)( )的含义</h2><ol><li>void (*0)( ) ：是一个返回值为void，参数为空的函数指针0。</li><li>(void (*)( ))0：把0转变成一个返回值为void，参数为空的函数指针。</li><li><em>(void(</em>)())0：在上句的基础上加*表示整个是一个返回值为void，无参数，并且起始地址为0的函数的名字。</li><li>(<em>(void (</em>)( ))0)( )：这就是上句的函数名所对应的函数的调用。</li></ol><h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h1><h2 id="简述一下堆和栈的区别"><a href="#简述一下堆和栈的区别" class="headerlink" title="简述一下堆和栈的区别"></a>简述一下堆和栈的区别</h2><p>分配和管理方式不同：</p><ul><li>堆是动态分配的，其空间的分配和释放都由程序员控制；</li><li>栈是由编译器自动管理的，其分配方式有两种：静态分配由编译器完成，比如局部变量的分配；动态分配由alloca()函数进行分配，但是会由编译器释放；<br>产生碎片不同：</li><li>对堆来说，频繁使用new&#x2F;delete或者malloc&#x2F;free会造成内存空间的不连续，产生大量碎片，使程序效率降低；</li><li>对栈来说，不存在碎片问题，因为栈具有先进后出的特性；<br>生长方向不同：</li><li>堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长；</li><li>栈是向着内存地址减小的方向增长的，从内存的高地址向低地址方向增长；<br>申请大小限制不同：</li><li>栈顶和栈底是预设好的，大小固定；</li><li>堆是不连续的内存区域，其大小可以灵活调整</li></ul><h2 id="内存的分配方式有几种？"><a href="#内存的分配方式有几种？" class="headerlink" title="内存的分配方式有几种？"></a>内存的分配方式有几种？</h2><ol><li>在栈上分配：在执行函数时，局部变量的内存都可以在栈上分配，函数结束时会自动释放；栈内存的分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限；</li><li>从堆上分配：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</li><li>从自由存储区分配：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，自由存储区和堆比较像，但不等价</li><li>从常量存储区分配：特殊的存储区，存放的是常量，不可修改；</li><li>从全局&#x2F;静态存储区分配：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</li></ol><h2 id="内存泄漏的场景有哪些？"><a href="#内存泄漏的场景有哪些？" class="headerlink" title="内存泄漏的场景有哪些？"></a>内存泄漏的场景有哪些？</h2><p>内存泄露：简单地说就是申请了一块内存空间，使用完毕后没有释放掉。</p><ol><li>malloc和free未成对出现；new&#x2F;new []和delete&#x2F;delete []未成对出现；</li><li>未定义拷贝构造函数或未重载赋值运算符，从而造成两次释放相同内存的做法；比如，类中包含指针成员变量，在未定义拷贝构造函数或未重载赋值运算符的情况下，编译器会调用默认的拷贝构造函数或赋值运算符，以逐个成员拷贝的方式来复制指针成员变量，使得两个对象包含指向同一内存空间的指针，那么在释放第一个对象时，析构函数释放该指针指向的内存空间，在释放第二个对象时，析构函数就会释放同一内存空间，这样的行为是错误的；</li><li>没有将基类的析构函数定义为虚函数。</li></ol><h2 id="malloc和局部变量分配在堆还是栈？"><a href="#malloc和局部变量分配在堆还是栈？" class="headerlink" title="malloc和局部变量分配在堆还是栈？"></a>malloc和局部变量分配在堆还是栈？</h2><p>malloc是在堆上分配内存，需要程序员自己回收内存；局部变量是在栈中分配内存，超过作用域就自动回收。</p><h2 id="程序有哪些section，分别的作用？"><a href="#程序有哪些section，分别的作用？" class="headerlink" title="程序有哪些section，分别的作用？"></a>程序有哪些section，分别的作用？</h2><p>从低地址到高地址，一个程序由代码段、数据段、 BSS 段组成。</p><ol><li>数据段：存放程序中已初始化的全局变量和静态变量的一块内存区域。</li><li>代码段：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。</li><li>BSS 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。<br>可执行程序在运行时又会多出两个区域：堆区和栈区。</li><li>堆区：动态申请内存用。堆从低地址向高地址增长。</li><li>栈区：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</li><li>最后还有一个文件映射区，位于堆和栈之间。</li></ol><h2 id="初始化为0的全局变量在bss还是data"><a href="#初始化为0的全局变量在bss还是data" class="headerlink" title="初始化为0的全局变量在bss还是data"></a>初始化为0的全局变量在bss还是data</h2><p>BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。</p><h2 id="new-delete和malloc-free之间有什么关系？"><a href="#new-delete和malloc-free之间有什么关系？" class="headerlink" title="new&#x2F;delete和malloc&#x2F;free之间有什么关系？"></a>new&#x2F;delete和malloc&#x2F;free之间有什么关系？</h2><ul><li>new与delete直接返回带具体类型的指针，malloc和free返回void类型的指针。</li><li>new类型是安全的，而malloc不是。例如int *p &#x3D; new float[2];就会报错；而int <em>p &#x3D; malloc(2</em>sizeof(int))编译时编译器就无法指出错误来。</li><li>new一般分为两步：new操作和构造。new操作对应与malloc，但new操作可以重载，可以自定义内存分配策略，不做内存分配，甚至分配到非内存设备上，而malloc不行。</li><li>new调用构造函数，malloc不能；delete调用析构函数，而free不能。</li><li>malloc&#x2F;free需要库文件stdlib.h的支持，new&#x2F;delete则不需要！<br>「注意」：delete和free被调用后，内存不会立即回收，指针也不会指向空，delete或free仅仅是告诉操作系统，这一块内存被释放了，可以用作其他用途。但是由于没有重新对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现野指针的情况。因此，释放完内存后，应该讲该指针指向NULL。</li></ul><h2 id="delete与delete-有什么区别？"><a href="#delete与delete-有什么区别？" class="headerlink" title="delete与delete []有什么区别？"></a>delete与delete []有什么区别？</h2><ol><li>对于简单类型来说，使用new分配后，不管是数组还是非数组形式，两种方式都可以释放内存：<br>对于自定义类型来说，就需要对于单个对象使用delete，对于对象数组使用delete []，逐个调用数组中对象的析构函数，从而释放所有内存；</li><li>如果反过来使用，即对于单个对象使用delete []，对于对象数组使用delete，其行为是未定义的；</li><li>所以，最恰当的方式就是如果用了new，就用delete；如果用了new []，就用delete []。<br>内存块太小导致malloc和new返回空指针，该怎么处理？</li><li>对于malloc来说，需要判断其是否返回空指针，如果是则马上用return语句终止该函数或者exit终止该程序；<br>对于new来说，默认抛出异常，所以可以使用try…catch…代码块的方式</li><li>还可以使用set_new_handler函数的方式</li></ol><h2 id="静态内存分配和动态内存分配有什么区别？"><a href="#静态内存分配和动态内存分配有什么区别？" class="headerlink" title="静态内存分配和动态内存分配有什么区别？"></a>静态内存分配和动态内存分配有什么区别？</h2><ol><li>静态内存分配是在编译时期完成的，不占用CPU资源；动态内存分配是在运行时期完成的，分配和释放需要占用CPU资源；</li><li>静态内存分配是在栈上分配的；动态内存分配是在堆上分配的；</li><li>静态内存分配不需要指针或引用类型的支持；动态内存分配需要；</li><li>静态内存分配是按计划分配的，在编译前确定内存块的大小；动态内存分配是按需要分配的；</li><li>静态内存分配是把内存的控制权交给了编译器；动态内存分配是把内存的控制权给了程序员；</li><li>静态内存分配的运行效率比动态内存分配高，动态内存分配不当可能造成内存泄漏。</li></ol><h2 id="如何构造一个类，使得只能在堆上或只能在栈上分配内存？"><a href="#如何构造一个类，使得只能在堆上或只能在栈上分配内存？" class="headerlink" title="如何构造一个类，使得只能在堆上或只能在栈上分配内存？"></a>如何构造一个类，使得只能在堆上或只能在栈上分配内存？</h2><ol><li>只能在堆上分配内存：将析构函数声明为private；（编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。所以将析构函数声明为private，不可访问，就无法将对象创建在栈上）</li><li>只能在栈上生成对象：将new和delete重载为private。（只要禁用new运算符就能够实现类对象只能创建在栈上）</li></ol><h2 id="在C-中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？"><a href="#在C-中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？" class="headerlink" title="在C++中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？"></a>在C++中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？</h2><p>不能。<br>malloc &#x2F;free主要为了兼容C，new和delete 完全可以取代malloc &#x2F;free的。malloc &#x2F;free的操作对象都是必须明确大小的。<br>而且不能用在动态类上。new 和delete会自动进行类型检查，也不需要自己明确内存大小，malloc&#x2F;free不能执行构造函数与析构函数，所以动态对象它是不行的。<br>当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。</p><h2 id="简述C-中内存对齐"><a href="#简述C-中内存对齐" class="headerlink" title="简述C++中内存对齐"></a>简述C++中内存对齐</h2><ol><li>数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。</li><li>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。</li><li>收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的”最宽基本类型成员”的整数倍。不足的要补齐。(基本类型不包括struct&#x2F;class&#x2F;uinon)。</li><li>sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。</li></ol><h2 id="为什么需要内存对齐呢？"><a href="#为什么需要内存对齐呢？" class="headerlink" title="为什么需要内存对齐呢？"></a>为什么需要内存对齐呢？</h2><p>因为CPU在访问内存时，并不是以单个字节为单位来访问的，而是以更大的数据块（例如4字节或8字节）为单位。如果数据的内存地址不是对齐的，那么CPU可能需要两次或更多的内存访问才能读取或写入数据，这会导致额外的开销。而通过对齐数据，CPU可以一次访问就读取或写入整个数据，从而提高了效率。</p><h2 id="说说new和malloc的区别，各自底层实现原理。"><a href="#说说new和malloc的区别，各自底层实现原理。" class="headerlink" title="说说new和malloc的区别，各自底层实现原理。"></a>说说new和malloc的区别，各自底层实现原理。</h2><p>malloc底层实现：当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K  时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。<br>new底层实现：关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p><ol><li>创建一个新的对象</li><li>将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="简述一下什么是面向对象"><a href="#简述一下什么是面向对象" class="headerlink" title="简述一下什么是面向对象"></a>简述一下什么是面向对象</h2><p>面向对象是一种编程思想，把一切东西看成是一个个对象，他们各自都有属性，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示<br>面向过程：根据业务逻辑从上到下写代码<br>面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程</p><h2 id="简述一下面向对象的三大特征"><a href="#简述一下面向对象的三大特征" class="headerlink" title="简述一下面向对象的三大特征"></a>简述一下面向对象的三大特征</h2><ol><li>封装：将客观事物封装成抽象的类，而类可以把自己的数据和方法暴露给可信的类或者对象，对不可信的类或对象则进行信息隐藏。</li><li>继承：可以使用现有类的所有功能，并且无需重新编写原来的类即可对功能进行拓展；</li><li>多态：一个类实例的相同方法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接口。对开放扩展，对修改关闭（开闭原则）</li></ol><h2 id="C-中类成员的访问权限"><a href="#C-中类成员的访问权限" class="headerlink" title="C++中类成员的访问权限"></a>C++中类成员的访问权限</h2><p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。<br>在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员</p><h2 id="说说类继承时，派生类对不同关键字修饰的基类方法的访问权限"><a href="#说说类继承时，派生类对不同关键字修饰的基类方法的访问权限" class="headerlink" title="说说类继承时，派生类对不同关键字修饰的基类方法的访问权限"></a>说说类继承时，派生类对不同关键字修饰的基类方法的访问权限</h2><p>类中的成员可以分为三种类型，分别为public成员、protected成员、private成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。<br>public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；</p><ol><li>派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。<br>protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；</li><li>派生类对象不可以访问基类的public、protected、private成员。<br>private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员；</li><li>派生类对象不可以访问基类的public、protected、private成员。</li></ol><h2 id="多态的实现有哪几种？"><a href="#多态的实现有哪几种？" class="headerlink" title="多态的实现有哪几种？"></a>多态的实现有哪几种？</h2><p>多态分为静态多态和动态多态。<br>其中，静态多态是通过重载和模板技术实现的，在编译期间确定；<br>动态多态是通过虚函数和继承关系实现的，执行动态绑定，在运行期间确定。</p><h2 id="动态绑定是如何实现的？"><a href="#动态绑定是如何实现的？" class="headerlink" title="动态绑定是如何实现的？"></a>动态绑定是如何实现的？</h2><p>当编译器发现类中有虚函数时，会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加一个指针vptr，用于指向类的虚函数表。当派生类覆盖基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用派生类中覆盖后的虚函数，从而实现动态绑定。</p><h2 id="动态多态有什么作用？有哪些必要条件？"><a href="#动态多态有什么作用？有哪些必要条件？" class="headerlink" title="动态多态有什么作用？有哪些必要条件？"></a>动态多态有什么作用？有哪些必要条件？</h2><p>动态多态的作用：</p><ul><li>隐藏实现细节，使代码模块化，提高代码的可复用性；</li><li>接口重用，使派生类的功能可以被基类的指针&#x2F;引用所调用，即向后兼容，提高代码的可扩充性和可维护性。<br>动态多态的必要条件：</li><li>需要有继承；</li><li>需要有虚函数覆盖；</li><li>需要有基类指针&#x2F;引用指向子类对象</li></ul><h2 id="虚函数表里存放的内容是什么时候写进去的？"><a href="#虚函数表里存放的内容是什么时候写进去的？" class="headerlink" title="虚函数表里存放的内容是什么时候写进去的？"></a>虚函数表里存放的内容是什么时候写进去的？</h2><ol><li>虚函数表是一个存储虚函数地址的数组,以NULL结尾。虚表（vftable）在编译阶段生成，对象内存空间开辟以后，写入对象中的 vfptr（虚函数指针），然后调用构造函数。即：虚表在构造函数之前写入</li><li>除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动态多态提供支持。</li></ol><h2 id="对虚函数和多态的理解"><a href="#对虚函数和多态的理解" class="headerlink" title="对虚函数和多态的理解"></a>对虚函数和多态的理解</h2><p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。<br>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p><h2 id="虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？"><a href="#虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？" class="headerlink" title="虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？"></a>虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？</h2><p>虚函数表是针对类的，<br>类的所有对象共享这个类的虚函数表，因为每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象的vptr的存放地址都不同，但都指向同一虚函数表。</p><h2 id="为什么基类的构造函数不能定义为虚函数？"><a href="#为什么基类的构造函数不能定义为虚函数？" class="headerlink" title="为什么基类的构造函数不能定义为虚函数？"></a>为什么基类的构造函数不能定义为虚函数？</h2><p>虚函数的调用依赖于虚函数表，而指向虚函数表的指针vptr需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。<br>为什么基类的析构函数需要定义为虚函数？<br>为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。</p><h2 id="纯虚函数有什么作用？如何实现？"><a href="#纯虚函数有什么作用？如何实现？" class="headerlink" title="纯虚函数有什么作用？如何实现？"></a>纯虚函数有什么作用？如何实现？</h2><p>定义纯虚函数是为了实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。<br>实现方式是在虚函数声明的结尾加上&#x3D; 0即可。</p><h2 id="说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？"><a href="#说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？" class="headerlink" title="说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？"></a>说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？</h2><ol><li>纯虚函数不可以实例化，但是可以用其派生类实例化</li><li>虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。<br>即“纯虚函数在类的vftable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”<br>所以纯虚函数不能实例化。</li><li>纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。</li><li>定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</li></ol><h2 id="说说C-中虚函数与纯虚函数的区别"><a href="#说说C-中虚函数与纯虚函数的区别" class="headerlink" title="说说C++中虚函数与纯虚函数的区别"></a>说说C++中虚函数与纯虚函数的区别</h2><ol><li>虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。</li><li>虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。</li><li>虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。</li><li>虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。</li><li>虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual  { } &#x3D; 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。</li></ol><h2 id="请问构造函数中的能不能调用虚方法"><a href="#请问构造函数中的能不能调用虚方法" class="headerlink" title="请问构造函数中的能不能调用虚方法"></a>请问构造函数中的能不能调用虚方法</h2><p>不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。<br>派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。<br>同样，进入基类析构函数时，对象也是基类类型。<br>所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。</p><h2 id="C-中哪些函数不能被声明为虚函数？"><a href="#C-中哪些函数不能被声明为虚函数？" class="headerlink" title="C++ 中哪些函数不能被声明为虚函数？"></a>C++ 中哪些函数不能被声明为虚函数？</h2><p>常见的不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。</p><ol><li>为什么C++不支持普通函数为虚函数？<br>普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。</li><li>为什么C++不支持构造函数为虚函数？<br>这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual  function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）<br>构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数</li><li>为什么C++不支持内联成员函数为虚函数？<br>其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数）</li><li>内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数</li><li>为什么C++不支持静态成员函数为虚函数？<br>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。<br>静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</li><li>为什么C++不支持友元函数为虚函数？<br>因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</li></ol><h2 id="构造函数和析构函数能抛出异常吗？"><a href="#构造函数和析构函数能抛出异常吗？" class="headerlink" title="构造函数和析构函数能抛出异常吗？"></a>构造函数和析构函数能抛出异常吗？</h2><ul><li>从语法的角度来说，构造函数可以抛出异常，但从逻辑和风险控制的角度来说，尽量不要抛出异常，否则可能导致内存泄漏。如果在构造函数的执行过程中抛出了异常，并且这个异常没有被捕获，那么该对象的析构函数将不会被调用，这可能导致资源泄露</li><li>析构函数不可以抛出异常，如果析构函数抛出异常，则异常点之后的程序，比如释放内存等操作，就不会被执行，从而造成内存泄露的问题；而且当异常发生时，C++通常会调用对象的析构函数来释放资源，如果此时析构函数也抛出异常，即前一个异常未处理又出现了新的异常，从而造成程序崩溃的问题。</li></ul><h2 id="请问拷贝构造函数的参数是什么传递方式，为什么"><a href="#请问拷贝构造函数的参数是什么传递方式，为什么" class="headerlink" title="请问拷贝构造函数的参数是什么传递方式，为什么"></a>请问拷贝构造函数的参数是什么传递方式，为什么</h2><ol><li>拷贝构造函数的参数必须使用引用传递<br>如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass  c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。</li><li>需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。</li></ol><h2 id="如何让一个类不能实例化？"><a href="#如何让一个类不能实例化？" class="headerlink" title="如何让一个类不能实例化？"></a>如何让一个类不能实例化？</h2><p>将类定义为抽象类（也就是存在纯虚函数）或者将构造函数声明为private。<br>多继承存在什么问题？如何消除多继承中的二义性？</p><ol><li>增加程序的复杂度，使得程序的编写和维护比较困难，容易出错；</li><li>在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性；<br>消除同名二义性的方法：</li></ol><ul><li>利用作用域运算符::，用于限定派生类使用的是哪个基类的成员；</li><li>在派生类中定义同名成员，覆盖基类中的相关成员；<br>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即路径二义性；<br>消除路径二义性的方法：</li><li>消除同名二义性的两种方法都可以；</li><li>使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝。</li></ul><h2 id="如果类A是一个空类，那么sizeof-A-的值为多少？"><a href="#如果类A是一个空类，那么sizeof-A-的值为多少？" class="headerlink" title="如果类A是一个空类，那么sizeof(A)的值为多少？"></a>如果类A是一个空类，那么sizeof(A)的值为多少？</h2><p>sizeof(A)的值为1，因为编译器需要区分这个空类的不同实例，分配一个字节，可以使这个空类的不同实例拥有独一无二的地址。</p><h2 id="覆盖和重载之间有什么区别？"><a href="#覆盖和重载之间有什么区别？" class="headerlink" title="覆盖和重载之间有什么区别？"></a>覆盖和重载之间有什么区别？</h2><ul><li>覆盖是指派生类中重新定义的函数，其函数名、参数列表、返回类型与父类完全相同，只是函数体存在区别；覆盖只发生在类的成员函数中；</li><li>重载是指两个函数具有相同的函数名，不同的参数列表，不关心返回值；当调用函数时，根据传递的参数列表来判断调用哪个函数；重载可以是类的成员函数，也可以是普通函数。</li></ul><h2 id="拷贝构造函数和赋值运算符重载之间有什么区别？"><a href="#拷贝构造函数和赋值运算符重载之间有什么区别？" class="headerlink" title="拷贝构造函数和赋值运算符重载之间有什么区别？"></a>拷贝构造函数和赋值运算符重载之间有什么区别？</h2><p>拷贝构造函数用于构造新的对象；<br>Student s;Student s1 &#x3D; s; &#x2F;&#x2F; 隐式调用拷贝构造函数Student s2(s);  &#x2F;&#x2F; 显式调用拷贝构造函数<br>赋值运算符重载用于将源对象的内容拷贝到目标对象中，而且源对象中包含未释放的内存时需要先将其释放；<br>Student s;Student s1;s1 &#x3D; s; &#x2F;&#x2F; 使用赋值运算符<br>一般情况下，类中包含指针变量时需要重载拷贝构造函数、赋值运算符和析构函数。</p><h2 id="说说C-结构体和C结构体的区别"><a href="#说说C-结构体和C结构体的区别" class="headerlink" title="说说C++结构体和C结构体的区别"></a>说说C++结构体和C结构体的区别</h2><ul><li>C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。</li><li>C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。</li><li>C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。</li><li>C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。</li></ul><h2 id="请你来说一下C-中struct和class的区别"><a href="#请你来说一下C-中struct和class的区别" class="headerlink" title="请你来说一下C++中struct和class的区别"></a>请你来说一下C++中struct和class的区别</h2><p>在C++中，class和struct做类型定义如下区别：</p><ul><li>默认继承权限不同，class继承默认是private继承，而struct默认是public继承</li><li>class还可用于定义模板参数，像typename，但是关键字struct不能用于定义模板参数</li></ul><h2 id="简述类成员函数的重写、重载和隐藏的区别"><a href="#简述类成员函数的重写、重载和隐藏的区别" class="headerlink" title="简述类成员函数的重写、重载和隐藏的区别"></a>简述类成员函数的重写、重载和隐藏的区别</h2><p>（1）重写和重载主要有以下几点不同。</p><ul><li>范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。</li><li>参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一 定不同。</li><li>virtual 的区别：重写的基类中被重写的函数必须要有virtual 修饰，而重载函数和被重载函数可以被 virtual 修饰，也可以没有。<br>（2）隐藏和重写、重载有以下几点不同。</li><li>与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中。</li><li>参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。当参数不相同时，无论基类中的函数是否被virtual 修饰，基类的函数都是被隐藏，而不是被重写。<br>「注意」：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完 全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。</li></ul><h2 id="RTTI是什么？其原理是什么？"><a href="#RTTI是什么？其原理是什么？" class="headerlink" title="RTTI是什么？其原理是什么？"></a>RTTI是什么？其原理是什么？</h2><p>RTTI即运行时类型识别，其功能由两个运算符实现：</p><ul><li>typeid运算符，用于返回表达式的类型，可以通过基类的指针获取派生类的数据类型；</li><li>dynamic_cast运算符，具有类型检查的功能，用于将基类的指针或引用安全地转换成派生类的指针或引用。</li></ul><h2 id="C-的空类有哪些成员函数"><a href="#C-的空类有哪些成员函数" class="headerlink" title="C++的空类有哪些成员函数"></a>C++的空类有哪些成员函数</h2><ul><li>缺省构造函数。</li><li>缺省拷贝构造函数。</li><li>析构函数。</li><li>赋值运算符。</li><li>取址运算符。</li><li>取址运算符 const 。<br>「注意」：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是 空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。</li></ul><h2 id="说说-C-类对象的初始化顺序，有多重继承情况下的顺序"><a href="#说说-C-类对象的初始化顺序，有多重继承情况下的顺序" class="headerlink" title="说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序"></a>说说 C++ 类对象的初始化顺序，有多重继承情况下的顺序</h2><p>父类构造函数–&gt;成员类对象构造函数–&gt;自身构造函数<br>其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。<br>析构顺序和构造顺序相反。</p><h2 id="简述下向上转型和向下转型"><a href="#简述下向上转型和向下转型" class="headerlink" title="简述下向上转型和向下转型"></a>简述下向上转型和向下转型</h2><ol><li>子类转换为父类：向上转型，使用dynamic_cast(expression)，这种转换相对来说比较安全不会有数据的丢失；</li><li>父类转换为子类：向下转型，可以使用强制转换，这种转换时不安全的，会导致数据的丢失，原因是父类的指针或者引用的内存中可能不包含子类的成员的内存。</li></ol><h2 id="简述下深拷贝和浅拷贝，如何实现深拷贝"><a href="#简述下深拷贝和浅拷贝，如何实现深拷贝" class="headerlink" title="简述下深拷贝和浅拷贝，如何实现深拷贝"></a>简述下深拷贝和浅拷贝，如何实现深拷贝</h2><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享一块内存；<br>而深拷贝会创造一个相同的对象，新对象与原对象不共享内存，修改新对象不会影响原对象。</p><h2 id="简述一下移动构造函数"><a href="#简述一下移动构造函数" class="headerlink" title="简述一下移动构造函数"></a>简述一下移动构造函数</h2><p>C++11中新增了移动构造函数。与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作。<br>移动操作的概念对对象管理它们使用的存储空间很有用的，诸如对象使用new和delete分配内存的时候。在这类对象中，拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。<br>而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。</p><h2 id="简述一下拷贝赋值和移动赋值？"><a href="#简述一下拷贝赋值和移动赋值？" class="headerlink" title="简述一下拷贝赋值和移动赋值？"></a>简述一下拷贝赋值和移动赋值？</h2><ol><li>拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。<br>移动赋值是通过移动构造函数来赋值，二者的主要区别在于</li><li>拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；</li><li>拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。</li></ol><h2 id="请你回答一下-C-类内可以定义引用数据成员吗？"><a href="#请你回答一下-C-类内可以定义引用数据成员吗？" class="headerlink" title="请你回答一下 C++ 类内可以定义引用数据成员吗？"></a>请你回答一下 C++ 类内可以定义引用数据成员吗？</h2><p>c++类内可以定义引用成员变量，但要遵循以下三个规则：</p><ol><li>不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。</li><li>构造函数的形参也必须是引用类型。</li><li>不能在构造函数里初始化，必须在初始化列表中进行初始化。</li></ol><h2 id="简述一下什么是常函数，有什么作用"><a href="#简述一下什么是常函数，有什么作用" class="headerlink" title="简述一下什么是常函数，有什么作用"></a>简述一下什么是常函数，有什么作用</h2><p>类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。<br>有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员<br>常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。</p><h2 id="仿函数了解吗？有什么作用"><a href="#仿函数了解吗？有什么作用" class="headerlink" title="仿函数了解吗？有什么作用"></a>仿函数了解吗？有什么作用</h2><p>仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符</p><h2 id="模板实例化和模板特例化"><a href="#模板实例化和模板特例化" class="headerlink" title="模板实例化和模板特例化"></a>模板实例化和模板特例化</h2><p>模板实例化：模板的实例化分为显示实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的<br>模板特例化：当模板使用某种类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行特例化。特例化时可以修改原模板的定义，当使用该类型时，按照特例化后的定义实现，特例化相当于对某种类型进行特殊处理。</p><h2 id="解释下-C-中类模板和模板类的区别"><a href="#解释下-C-中类模板和模板类的区别" class="headerlink" title="解释下 C++ 中类模板和模板类的区别"></a>解释下 C++ 中类模板和模板类的区别</h2><ol><li>类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数</li><li>模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。</li></ol><h1 id="STL特性"><a href="#STL特性" class="headerlink" title="STL特性"></a>STL特性</h1><h2 id="什么是C-STL？"><a href="#什么是C-STL？" class="headerlink" title="什么是C++ STL？"></a>什么是C++ STL？</h2><p>STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。</p><ol><li>容器(Container)<br>是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。 </li><li>算法（Algorithm）<br>是用来操作容器中的数据的模板函数。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。 </li><li>迭代器（Iterator）<br>提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。  迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。  但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象; </li><li>仿函数（Function object）<br>仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。 </li><li>适配器（Adaptor）<br>简单的说就是一种接口类，专门用来修改现有类的接口，提供一种新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。 </li><li>空间配制器（Allocator）<br>为STL提供空间配置的系统。其中主要工作包括两部分：<br>（1）对象的创建与销毁<br>（2）内存的获取与释放。</li></ol><h2 id="请说说-STL-中常见的容器，并介绍一下实现原理"><a href="#请说说-STL-中常见的容器，并介绍一下实现原理" class="headerlink" title="请说说 STL 中常见的容器，并介绍一下实现原理"></a>请说说 STL 中常见的容器，并介绍一下实现原理</h2><p>容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：</p><ol><li>顺序容器<br>容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：<br>（1）vector    头文件<br>动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。<br>（2）deque    头文件<br>双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。<br>（3）list    头文件<br>双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</li><li>关联式容器<br>元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：<br>（1）set&#x2F;multiset    头文件<br>set 即集合。set中不允许相同元素，multiset中允许存在相同元素。<br>（2）map&#x2F;multimap    头文件<br>map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素。<br>注意：map同multimap的不同在于是否允许相同first值的元素。</li><li>容器适配器<br>封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue，具体实现原理如下：<br>（1）stack    头文件<br>栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。后进先出。<br>（2）queue    头文件<br>队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。先进先出。<br>（3）priority_queue    头文件<br>优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。最高优先级元素总是第一个出列。</li></ol><h2 id="什么时候需要用hash-map，什么时候需要用map"><a href="#什么时候需要用hash-map，什么时候需要用map" class="headerlink" title="什么时候需要用hash_map，什么时候需要用map?"></a>什么时候需要用hash_map，什么时候需要用map?</h2><p>总体来说，hash_map 查找速度会比 map 快，而且查找速度基本和数据数据量大小无关，属于常数级别;而 map 的查找速度是 log(n) 级别。<br>但是并不一定常数就比 log(n) 小，hash 还有 hash 函数的耗时，如果考虑效率，特别是在元素达到一定数量级时，考虑 用hash_map。<br>但若对内存使用特别严格，希望程序尽可能少消耗内存，那么hash_map 可能会让你陷入尴尬，特别是当你的 hash_map 对象特别多时，就更无法控制了。而且hash_map 的构造速度较慢。</p><h2 id="vector的底层原理"><a href="#vector的底层原理" class="headerlink" title="vector的底层原理"></a>vector的底层原理</h2><p>vector底层是一个动态数组，包含三个迭代器，start和finish之间是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。<br>当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【vector内存增长机制】。<br>当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。<br>因此，对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器会都失效了。</p><h2 id="vector中的reserve和resize的区别"><a href="#vector中的reserve和resize的区别" class="headerlink" title="vector中的reserve和resize的区别"></a>vector中的reserve和resize的区别</h2><p>（1）resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。<br>（2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。<br>（3）两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。<br>reserve 函数用于预先分配内存空间，而 resize 函数用于改变 std::vector 的大小。</p><h2 id="vector中的size和capacity的区别"><a href="#vector中的size和capacity的区别" class="headerlink" title="vector中的size和capacity的区别"></a>vector中的size和capacity的区别</h2><p>size表示当前vector中有多少个元素（finish – start），而capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage – start）。</p><h2 id="vector的元素类型可以是引用吗？"><a href="#vector的元素类型可以是引用吗？" class="headerlink" title="vector的元素类型可以是引用吗？"></a>vector的元素类型可以是引用吗？</h2><p>vector的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此vector的元素类型不能是引用。</p><h2 id="vector迭代器失效的情况"><a href="#vector迭代器失效的情况" class="headerlink" title="vector迭代器失效的情况"></a>vector迭代器失效的情况</h2><p>当插入一个元素到vector中，如果引起了内存重新分配，所以指向原内存的迭代器全部失效。<br>当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要it&#x3D;vec.erase(it);。</p><h2 id="vector循环删除元素正确方式"><a href="#vector循环删除元素正确方式" class="headerlink" title="vector循环删除元素正确方式"></a>vector循环删除元素正确方式</h2><p>在C++中，循环删除std::vector中的元素时，确实需要注意不要破坏迭代器或索引的有效性。下面提供了几种正确循环删除vector中元素的方法：<br>1、方法一：从后向前遍历并删除<br>从后向前遍历vector并删除奇数位元素是一种安全的方法，因为删除操作不会影响到尚未处理的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = vec.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123; <span class="comment">// 检查索引是否为奇数  </span></span><br><span class="line">        vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + i); <span class="comment">// 删除奇数位元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、方法二：使用迭代器并更新迭代器<br>当使用迭代器遍历vector时，如果删除元素，必须更新迭代器以避免悬挂迭代器。<br>不能使用vector的size，因为在删除后，size就改变了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;  </span><br><span class="line"><span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it=vec.<span class="built_in">begin</span>();it!=vec.<span class="built_in">end</span>();) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (index % <span class="number">2</span> != <span class="number">0</span>) &#123; <span class="comment">// 检查索引是否为奇数  </span></span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it); <span class="comment">// 删除元素并更新迭代器  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        ++it; <span class="comment">// 只递增迭代器，不删除元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确释放vector的内存-clear-swap-shrink-to-fit"><a href="#正确释放vector的内存-clear-swap-shrink-to-fit" class="headerlink" title="正确释放vector的内存(clear(), swap(), shrink_to_fit())"></a>正确释放vector的内存(clear(), swap(), shrink_to_fit())</h2><p>vec.clear()：清空内容，但是不释放内存。<br>vector().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。<br>vec.shrink_to_fit()：请求容器降低其capacity和size匹配。<br>vec.clear();vec.shrink_to_fit();：清空内容，且释放内存。</p><h2 id="vector如何释放空间"><a href="#vector如何释放空间" class="headerlink" title="vector如何释放空间?"></a>vector如何释放空间?</h2><p>由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。<br>如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。</p><h2 id="为什么vector的插入操作可能会导致迭代器失效？"><a href="#为什么vector的插入操作可能会导致迭代器失效？" class="headerlink" title="为什么vector的插入操作可能会导致迭代器失效？"></a>为什么vector的插入操作可能会导致迭代器失效？</h2><p>vector动态增加大小时，并不是在原空间后增加新的空间，而是以原大小的两倍在另外配置一片较大的新空间，然后将内容拷贝过来，并释放原来的空间。由于操作改变了空间，所以迭代器失效。</p><h2 id="list的底层原理"><a href="#list的底层原理" class="headerlink" title="list的底层原理"></a>list的底层原理</h2><p>list的底层是一个双向链表，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间。<br>list不支持随机存取，适合需要大量的插入和删除，而不关心随即存取的应用场景。</p><h2 id="deque的底层原理"><a href="#deque的底层原理" class="headerlink" title="deque的底层原理"></a>deque的底层原理</h2><p>deque是一个双向开口的连续线性空间（双端队列），在头尾两端进行元素的插入跟删除操作都有理想的时间复杂度。</p><h2 id="什么情况下用vector，什么情况下用list，什么情况下用deque"><a href="#什么情况下用vector，什么情况下用list，什么情况下用deque" class="headerlink" title="什么情况下用vector，什么情况下用list，什么情况下用deque"></a>什么情况下用vector，什么情况下用list，什么情况下用deque</h2><p>vector可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），但在非尾部插入删除数据时，效率很低，适合对象简单，对象数量变化不大，随机访问频繁。除非必要，我们尽可能选择使用vector而非deque，因为deque的迭代器比vector迭代器复杂很多。<br>list不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景。<br>需要从首尾两端进行插入或删除操作的时候需要选择deque。</p><h2 id="map-、set、multiset、multimap的底层原理"><a href="#map-、set、multiset、multimap的底层原理" class="headerlink" title="map 、set、multiset、multimap的底层原理"></a>map 、set、multiset、multimap的底层原理</h2><p>map 、set、multiset、multimap的底层实现都是红黑树，epoll模型的底层数据结构也是红黑树，linux系统中CFS进程调度算法，也用到红黑树。</p><h2 id="map-、set、multiset、multimap的特点"><a href="#map-、set、multiset、multimap的特点" class="headerlink" title="map 、set、multiset、multimap的特点"></a>map 、set、multiset、multimap的特点</h2><p>set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。<br>map和multimap将key和value组成的pair作为元素，根据key的排序准则自动将元素排序（因为红黑树也是二叉搜索树，所以map默认是按key排序的），map中元素的key不允许重复，multimap可以重复。<br>map和set的增删改查速度为都是logn，是比较高效的。</p><h2 id="为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？"><a href="#为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？" class="headerlink" title="为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？"></a>为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？</h2><p>因为存储的是结点，不需要内存拷贝和内存移动。<br>因为插入操作只是结点指针换来换去，结点内存没有改变。而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。</p><h2 id="为何map和set不能像vector一样有个reserve函数来预分配数据"><a href="#为何map和set不能像vector一样有个reserve函数来预分配数据" class="headerlink" title="为何map和set不能像vector一样有个reserve函数来预分配数据?"></a>为何map和set不能像vector一样有个reserve函数来预分配数据?</h2><p>因为在map和set内部存储的已经不是元素本身了，而是包含元素的结点。也就是说map内部使用的Alloc并不是map&lt;Key, Data, Compare, Alloc&gt;声明的时候从参数中传入的Alloc。</p><h2 id="unordered-map、unordered-set的底层原理"><a href="#unordered-map、unordered-set的底层原理" class="headerlink" title="unordered_map、unordered_set的底层原理"></a>unordered_map、unordered_set的底层原理</h2><p>unordered_map的底层是一个防冗余的哈希表（采用除留余数法）。哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，时间复杂度为O(1)；而代价仅仅是消耗比较多的内存。<br>使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数（一般使用除留取余法），也叫做散列函数），使得每个元素的key都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照key为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。<br>但是，不能够保证每个元素的key与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 一般可采用拉链法解决冲突</p><h2 id="unordered-map-与map的区别？使用场景？"><a href="#unordered-map-与map的区别？使用场景？" class="headerlink" title="unordered_map 与map的区别？使用场景？"></a>unordered_map 与map的区别？使用场景？</h2><p>构造函数：unordered_map 需要hash函数，等于函数;map只需要比较函数(小于函数).<br>存储结构：unordered_map 采用hash表存储，map一般采用红黑树(RB Tree) 实现。因此其memory数据结构是不一样的。</p><p>总体来说，unordered_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n)小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑unordered_map 。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，unordered_map 可能会让你陷入尴尬，特别是当你的unordered_map 对象特别多时，你就更无法控制了，而且unordered_map 的构造速度较慢。</p><h2 id="容器内部删除一个元素"><a href="#容器内部删除一个元素" class="headerlink" title="容器内部删除一个元素"></a>容器内部删除一个元素</h2><ol><li>顺序容器（序列式容器，比如vector、deque）<br>erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；<br>It &#x3D; c.erase(it);</li><li>关联容器(关联式容器，比如map、set、multimap、multiset等)<br>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；<br>c.erase(it++)</li></ol><h2 id="vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"><a href="#vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？" class="headerlink" title="vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"></a>vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？</h2><ol><li>通过下标访问vector中的元素时会做边界检查，但该处的实现方式要看具体IDE，不同IDE的实现方式不一样，确保不可访问越界地址。</li><li>map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的某人值插入这个map。</li><li>erase()函数，只能删除内容，不能改变容量大小;<br>erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针;clear()函数，只能清空内容，不能改变容量大小;如果要想在删除内容的同时释放内存，那么你可以选择deque容器。</li></ol><h2 id="map中-与find的区别？"><a href="#map中-与find的区别？" class="headerlink" title="map中[ ]与find的区别？"></a>map中[ ]与find的区别？</h2><ol><li>map的下标运算符[ ]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</li><li>map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。<br>频繁对vector调用push_back()对性能的影响和原因？<br>在一个vector的尾部之外的任何位置添加元素，都需要重新移动元素。而且，向一个vector添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移到新的空间。</li></ol><h2 id="请你来介绍一下-STL-的空间配置器（allocator）"><a href="#请你来介绍一下-STL-的空间配置器（allocator）" class="headerlink" title="请你来介绍一下 STL 的空间配置器（allocator）"></a>请你来介绍一下 STL 的空间配置器（allocator）</h2><p>一般情况下,一个程序包括数据结构和相应的算法，而数据结构作为存储数据的组织形式，与内存空间有着密切的联系。在C++  STL中，空间配置器便是用来实现内存空间(一般是内存，也可以是硬盘等空间)分配的工具，他与容器联系紧密，每一种容器的空间分配都是通过空间分配器alloctor实现的。</p><h2 id="说说-push-back-和-emplace-back-的区别"><a href="#说说-push-back-和-emplace-back-的区别" class="headerlink" title="说说 push_back 和 emplace_back 的区别"></a>说说 push_back 和 emplace_back 的区别</h2><p>如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。<br>push_back 会创建一个新的对象，然后将其拷贝或移动到向量中，而 emplace_back 会直接在向量末尾构造对象，避免额外的拷贝或移动操作。</p><h1 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++新特性"></a>C++新特性</h1><h2 id="简述-C-右值引用与转移语义"><a href="#简述-C-右值引用与转移语义" class="headerlink" title="简述 C++ 右值引用与转移语义"></a>简述 C++ 右值引用与转移语义</h2><p>右值引用</p><ol><li>一般来说，不能取地址的表达式，就是右值引用，能取地址的，就是左值。 </li><li>右值引用的主要目的是为了实现转移语义和完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数<br>转移语义</li><li>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。</li></ol><h2 id="什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？"><a href="#什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？" class="headerlink" title="什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？"></a>什么是智能指针？智能指针有什么作用？分为哪几种？各自有什么样的特点？</h2><p>智能指针是一个RAII类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用delete删除指针所指向的内存空间。<br>智能指针的作用是，能够处理内存泄漏问题和空悬指针问题。<br>分为auto_ptr、unique_ptr、shared_ptr和weak_ptr四种，各自的特点： </p><ol><li>对于auto_ptr，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象；但auto_ptr在C++11中被摒弃，其主要问题在于：</li></ol><ul><li>对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题；</li><li>不能指向数组，也不能作为STL容器的成员。</li></ul><ol start="2"><li>对于unique_ptr，实现独占式拥有的概念，同一时间只能有一个智能指针可以指向该对象，因为无法进行拷贝构造和拷贝赋值，但是可以进行移动构造和移动赋值； <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; value_ &lt;&lt; std::endl; &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> value_;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> MyClass(<span class="number">5</span>))</span></span>;  </span><br><span class="line">    ptr-&gt;<span class="built_in">printValue</span>();  <span class="comment">// 输出: 5  </span></span><br><span class="line">    <span class="comment">// 当ptr离开作用域时，它会自动删除它所指向的MyClass对象  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对于shared_ptr，实现共享式拥有的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源； <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; value_ &lt;&lt; std::endl; &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> value_;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">5</span>);  </span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1;  <span class="comment">// ptr1和ptr2现在共享同一个MyClass对象  </span></span><br><span class="line">    ptr1-&gt;<span class="built_in">printValue</span>();  <span class="comment">// 输出: 5  </span></span><br><span class="line">    ptr2-&gt;<span class="built_in">printValue</span>();  <span class="comment">// 输出: 5  </span></span><br><span class="line">    <span class="comment">// 当ptr1和ptr2都离开作用域时，它们共享的MyClass对象才会被删除  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对于weak_ptr，解决shared_ptr相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而weak_ptr是对对象的一种弱引用，可以绑定到shared_ptr，但不会增加对象的引用计数。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; value_ &lt;&lt; std::endl; &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> value_;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; ptr = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">5</span>);  </span><br><span class="line">    std::weak_ptr&lt;MyClass&gt; weakPtr = ptr;  </span><br><span class="line">    <span class="comment">// 在某些情况下，可以使用weakPtr.lock()来获取一个临时的shared_ptr  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> tempPtr = weakPtr.<span class="built_in">lock</span>()) &#123;  </span><br><span class="line">        tempPtr-&gt;<span class="built_in">printValue</span>();  <span class="comment">// 输出: 5  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 当ptr离开作用域时，它会自动删除它所指向的MyClass对象，此时weakPtr变为无效  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。同时，weak_ptr 必须从一个share_ptr或者另一个weak_ptr转换而来，不能使用new 对象进行构造。由于弱引用不更改引用计数，类似普通指针，只要把循环引用的一方使用弱引用，即可解除循环引用。<br>循环引用例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        std::shared_ptr&lt;B&gt; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        std::shared_ptr&lt;A&gt; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">        pa-&gt;ptr = pb;</span><br><span class="line">        pb-&gt;ptr = pa;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出A和B，没有输出~A和~B</span></span><br></pre></td></tr></table></figure><!--/img/C++八股文/shareptr1.png --><a href="https://www.imagehub.cc/image/1YycXh"><img src="https://s1.imagehub.cc/images/2024/04/15/efae464a622aa5aaef5cdcb980f79a9f.png" alt="efae464a622aa5aaef5cdcb980f79a9f.png"></a><br>对象A同时被pa和对象B中的ptr两个智能指针托管，所以引用计数为2；对象B同时被pb和对象A中的ptr两个智能指针托管，所以引用计数也为2。那么当fun函数执行完，栈对象pb、pa依次开始执行析构函数<br>紧接着内存布局就变成了这样：<!--/img/C++八股文/shareptr2.png --><a href="https://www.imagehub.cc/image/1YyR8I"><img src="https://s1.imagehub.cc/images/2024/04/15/d7d06697792031251d61625acbcc4094.png" alt="d7d06697792031251d61625acbcc4094.png"></a><br>pa和pb已经销毁了，然而对象A和B，已经迷失在这浩瀚内存中，亘古难灭。称之为循环引用<br>为了解决shared_ptr在在循环引用中存在的资源泄漏问题，weak_ptr在这种场景下应用而生，weak_ptr指向的智能指针对象，其引用计数不会加一，也就不会存在无法释放的问题了。<br>解决的方法就是，把A和B其中的一个ptr改成weak_ptr。</li></ol><h2 id="简述一下-C-11-中四种类型转换"><a href="#简述一下-C-11-中四种类型转换" class="headerlink" title="简述一下 C++11 中四种类型转换"></a>简述一下 C++11 中四种类型转换</h2><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast<br>1、const_cast</p><ul><li>用于将const变量转为非const</li><li>const_cast 用于增加或去除类型的 const 或 volatile 属性。它常常被用于调用一些需要非 const 参数的函数，而实际传入的参数却是 const 的。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;  </span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;a); <span class="comment">// 去除 const 属性  </span></span><br><span class="line">*p = <span class="number">20</span>; <span class="comment">// 未定义行为，因为 a 本质上是 const 的</span></span><br></pre></td></tr></table></figure>2、static_cast</li><li>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；<br>static_cast 用于基础数据类型之间的转换（如 int、float、double 等）、非多态类型之间的转换、空指针和空指针之间的转换，以及同一个继承层次内部类之间的转换。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;  </span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); <span class="comment">// int 到 float 的转换  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;  </span><br><span class="line"><span class="type">char</span>* non_const_str = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(str); <span class="comment">// 去除 const 修饰</span></span><br></pre></td></tr></table></figure>3、dynamic_cast<br>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</li><li>向上转换：指的是子类向基类的转换</li><li>向下转换：指的是基类向子类的转换<br>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。<br>dynamic_cast 主要用于类层次间的向上和向下转换，主要在运行时检查转换的有效性。它通常用于将基类指针转换为派生类指针或引用。如果转换不可能进行（即不是有效的向下转换），dynamic_cast 将返回空指针。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived instance&quot;</span> &lt;&lt; std::endl; &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Base* base = <span class="keyword">new</span> <span class="built_in">Derived</span>();  </span><br><span class="line">    Derived* derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base);  </span><br><span class="line">    <span class="keyword">if</span> (derived) &#123;  </span><br><span class="line">        derived-&gt;<span class="built_in">print</span>(); <span class="comment">// 输出 &quot;Derived instance&quot;  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">delete</span> base;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>4、reinterpret_cast</li><li>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；<br>reinterpret_cast 提供了一种在不同类型的指针或整数类型之间转换的低级别方式。这种转换不执行任何类型检查或格式转换，仅仅是重新解释位模式，因此它是非常不安全的。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">12345</span>;  </span><br><span class="line"><span class="type">int</span>* p_int = &amp;a;  </span><br><span class="line"><span class="type">char</span>* p_char = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(p_int); <span class="comment">// int* 到 char* 的转换</span></span><br></pre></td></tr></table></figure>5、为什么不使用C的强制转换？</li><li>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</li></ul><h2 id="简述一下-C-11-中-auto-的具体用法"><a href="#简述一下-C-11-中-auto-的具体用法" class="headerlink" title="简述一下 C++ 11 中 auto 的具体用法"></a>简述一下 C++ 11 中 auto 的具体用法</h2><p>auto用于定义变量，编译器可以自动判断变量的类型。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="makefile和cmake"><a href="#makefile和cmake" class="headerlink" title="makefile和cmake"></a>makefile和cmake</h2><p>CMake和Makefile都是用于自动化构建和管理项目的工具，但它们之间存在一些显著的区别。<br>1、makefile<br>（1）Makefile是一种文件，它定义了一个项目中的编译规则、依赖关系和构建过程。<br>（2）它通常用于编译源代码、链接对象文件以生成可执行文件或库文件。<br>（3）Makefile的语法较为低级，需要手动编写规则和依赖关系。<br>其核心思想是根据文件的最后修改时间来确定哪些部分需要重新编译，以及以什么顺序来执行编译步骤。每个规则由一个目标（target）和一组依赖项（dependencies）组成，以及执行指令（commands）。Makefile的缺点是跨平台性较差，通常需要为特定平台和编译器编写，因此，当项目需要在不同平台上构建时，可能需要多个Makefile文件。<br>2、CMake<br>（1）CMake是一个跨平台的安装（编译）工具，它使用简单的语句来描述所有平台的安装（编译）过程。<br>（2）CMake能够输出各种各样的Makefile或者其他类型的项目文件，如Visual   Studio项目文件、Ninja构建文件等。这使得项目可以使用不同的构建系统来构建，而不必更改CMakeLists.txt文件。<br>（3）CMake并不直接构建出最终的软件，而是产生标准的构建文件，然后再依一般的构建方式使用。这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式构建软件。<br>（4）CMake的组态档通常命名为CMakeLists.txt。<br>总结来说，CMake和Makefile的主要区别在于跨平台性、生成的文件类型以及使用的便捷性。CMake具有更好的跨平台性，可以生成多种类型的构建文件，而Makefile则更适用于特定平台和编译器的构建。在使用上，CMake通过更高级别的语句来描述构建过程，使得编写和维护构建规则更为便捷。而Makefile则需要手动编写相对低级的语法，因此在构建复杂项目时可能会更为繁琐。<br>例子：<br>1、CMake<br>首先，创建一个名为CMakeLists.txt的文件，这个文件描述了如何构建你的项目。对于我们的简单例子，CMakeLists.txt可能如下所示：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定CMake的最低版本要求  </span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置项目名称  </span></span><br><span class="line"><span class="keyword">project</span>(MyProject)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置C++标准  </span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)  </span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加源文件到可执行文件  </span></span><br><span class="line"><span class="keyword">add_executable</span>(MyProject main.cpp)</span><br></pre></td></tr></table></figure><p>在这个文件中，我们指定了CMake的最低版本要求，设置了项目名称，并设置了C++标准。最后，我们使用add_executable命令将源文件main.cpp添加到一个名为MyProject的可执行文件中。<br>接下来，你需要在项目目录中创建一个名为build的子目录（或者任何你喜欢的名称），并在这个子目录中运行CMake来生成构建文件。在命令行中执行以下命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir build  </span><br><span class="line">cd build  </span><br><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>这里的cmake ..命令告诉CMake从上一级目录（..）中的CMakeLists.txt文件读取构建指令。CMake将生成Makefile或其他构建系统文件（取决于你的平台和配置）。<br>一旦CMake运行成功，你就可以使用生成的构建文件来构建你的项目了。在Unix-like系统中（包括Linux和macOS），你可以使用make命令来构建项目：<br><code>make</code><br>这将编译main.cpp并链接生成可执行文件MyProject。在Windows系统中，如果你使用的是Visual Studio的生成器，那么可以直接打开生成的解决方案文件（通常是.sln文件）并在IDE中构建项目。<br>构建完成后，你可以在build目录中找到生成的可执行文件MyProject，并运行它<br>2、makefile<br>创建一个名为Makefile的文件，内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义编译器  </span></span><br><span class="line">CC=gcc  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 定义编译器参数  </span></span><br><span class="line">CFLAGS=-Wall  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 定义源文件  </span></span><br><span class="line">SRCS=main.c  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 定义目标文件，将源文件后缀替换为.o  </span></span><br><span class="line">OBJS=$(SRCS:.c=.o)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 定义最终生成的可执行文件名  </span></span><br><span class="line">TARGET=myprogram  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 默认目标，即make命令不带任何参数时的目标  </span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 生成可执行文件的规则  </span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span>  </span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$^</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 生成目标文件的规则，%.o: %.c 表示所有的.o文件都依赖于相应的.c文件  </span></span><br><span class="line"><span class="section">%.o: %.c  </span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 清除所有编译生成的文件  </span></span><br><span class="line"><span class="section">clean:  </span></span><br><span class="line">        rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>在这个Makefile中：</p><ul><li>CC 和 CFLAGS 分别定义了使用的编译器和编译器的标志。</li><li>SRCS 包含了所有源文件。</li><li>OBJS 通过将源文件列表中的.c后缀替换为.o来生成目标文件列表。</li><li>TARGET 是最终生成的可执行文件的名称。</li><li>all 是默认目标，它依赖于$(TARGET)，即当执行make命令时不带任何参数时，会构建可执行文件。</li><li>$$(TARGET): $$(OBJS) 规则表示要生成可执行文件，需要所有的目标文件。</li><li>%.o: %.c 是一个模式规则，它告诉make如何将每个.c源文件编译成相应的.o目标文件。</li><li>clean 目标是一个伪目标（不以文件命名的目标），用于删除所有编译生成的文件。<br>现在，你可以在命令行中执行以下命令来构建你的项目：<br><code>make</code><br>这将编译main.c文件，生成main.o目标文件，并链接生成myprogram可执行文件。<br>如果你想要清除编译生成的所有文件，可以执行：<br><code>make clean</code><br>这将删除所有的.o目标文件和myprogram可执行文件。<br>这个Makefile构建例子是非常基础的，但展示了Makefile的基本结构和一些常用的规则。对于更复杂的项目，Makefile可能会包含更多的源文件、依赖的库、安装规则等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
